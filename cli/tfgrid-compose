#!/usr/bin/env bash
# TFGrid Compose - Main CLI entry point

set -e

# Get script directory
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
DEPLOYER_ROOT="$(cd "$SCRIPT_DIR/.." && pwd)"

# Source core modules
source "$DEPLOYER_ROOT/core/common.sh"
source "$DEPLOYER_ROOT/core/validation.sh"
source "$DEPLOYER_ROOT/core/pattern-loader.sh"
source "$DEPLOYER_ROOT/core/app-loader.sh"
source "$DEPLOYER_ROOT/core/orchestrator.sh"
source "$DEPLOYER_ROOT/core/registry.sh"
source "$DEPLOYER_ROOT/core/app-cache.sh"
source "$DEPLOYER_ROOT/core/pre-cache-registry.sh"
source "$DEPLOYER_ROOT/core/deployment-state.sh"
source "$DEPLOYER_ROOT/core/deployment-status.sh"
source "$DEPLOYER_ROOT/core/signin.sh"
source "$DEPLOYER_ROOT/core/deployment-id.sh"
source "$DEPLOYER_ROOT/core/gitconfig.sh"
source "$DEPLOYER_ROOT/core/config.sh"
source "$DEPLOYER_ROOT/core/node-browser.sh"
source "$DEPLOYER_ROOT/core/update-git-config.sh"
source "$DEPLOYER_ROOT/core/contract-manager.sh"
source "$DEPLOYER_ROOT/core/preferences.sh"
source "$DEPLOYER_ROOT/core/network.sh"

# Version (enhanced with Git commit support)
# Load common functions
source "$DEPLOYER_ROOT/core/common.sh"

# Get enhanced version info
ENHANCED_VERSION=$(get_tfgrid_compose_version)
VERSION=$(echo "$ENHANCED_VERSION" | jq -r '.display // "unknown"')
SEMANTIC_VERSION=$(echo "$ENHANCED_VERSION" | jq -r '.semantic // "unknown"')
GIT_COMMIT=$(echo "$ENHANCED_VERSION" | jq -r '.git_commit // "unknown"')

# Context file support
CONTEXT_FILE=".tfgrid-compose.yaml"

# Enhanced version display function
display_version() {
    if [ "$GIT_COMMIT" != "unknown" ]; then
        echo "TFGrid Compose $VERSION"
        if [ "$SEMANTIC_VERSION" != "unknown" ] && [ "$GIT_COMMIT" != "$SEMANTIC_VERSION" ]; then
            echo "Semantic version: v$SEMANTIC_VERSION"
        fi
    else
        echo "TFGrid Compose v$VERSION"
    fi
}

# Enhanced log function for commands with version
log_command() {
    local command_name="$1"
    if [ "$GIT_COMMIT" != "unknown" ]; then
        log_info "TFGrid Compose $VERSION - $command_name"
    else
        log_info "TFGrid Compose v$VERSION - $command_name"
    fi
    echo ""
}

# Default manifest file
MANIFEST_FILE="tfgrid-compose.yaml"

# Load context from .tfgrid-compose.yaml or global current-app file
load_context() {
    # First try local context file
    if [ -f "$CONTEXT_FILE" ]; then
        grep "^app:" "$CONTEXT_FILE" | awk '{print $2}'
        return
    fi
    
    # Fall back to global current app (from switch command)
    if [ -f "$HOME/.config/tfgrid-compose/current-app" ]; then
        cat "$HOME/.config/tfgrid-compose/current-app"
    fi
}

# Get app command script path from manifest
get_app_command_script() {
    local app_path="$1"
    local command="$2"
    
    # Read command script from manifest (including any arguments after script path)
    grep -A 2 "^  ${command}:" "$app_path/tfgrid-compose.yaml" 2>/dev/null | \
        grep "script:" | sed 's/.*script:[[:space:]]*//'
}

# Check if selected app has a specific command
app_has_command() {
    local command="$1"
    
    # Get current app
    local current_app=$(get_current_app)
    if [ -z "$current_app" ]; then
        return 1
    fi
    
    # Resolve app path (handles both deployment IDs and app names)
    local app_path=$(resolve_app_path "$current_app" "true")
    if [ -z "$app_path" ] || [ ! -f "$app_path/tfgrid-compose.yaml" ]; then
        return 1
    fi
    
    # Check if command exists in manifest
    local script_path=$(get_app_command_script "$app_path" "$command")
    if [ -n "$script_path" ]; then
        return 0
    fi
    
    return 1
}
# Execute app-specific command
execute_app_command() {
    local command="$1"
    shift
    local args="$@"
    
    # Get smart context (auto-detect or use current)
    CONTEXT_APP=$(get_smart_context)
    
    if [ -z "$CONTEXT_APP" ]; then
        # Multiple or no apps, need explicit context
        log_error "No app selected"
        echo ""
        log_info "Deployed apps:"
        list_deployed_apps
        echo ""
        log_info "Select an app with: tfgrid-compose select <app>"
        return 1
    fi
    
    # Resolve app path (handles both deployment IDs and app names)
    APP_PATH=$(resolve_app_path "$CONTEXT_APP")
    if [ -z "$APP_PATH" ]; then
        log_error "Failed to resolve app: $CONTEXT_APP"
        return 1
    fi
    
    # Set APP_NAME from resolved path
    APP_NAME=$(basename "$APP_PATH")
    export APP_NAME
    
    # Get command script
    SCRIPT_PATH=$(get_app_command_script "$APP_PATH" "$command")
    
    if [ -z "$SCRIPT_PATH" ]; then
        log_error "Unknown command: $command"
        log_info "App '$APP_NAME' does not support command '$command'"
        echo ""
        log_info "Run 'tfgrid-compose help' to see available commands"
        return 1
    fi
    
    export APP_NAME
    
    # Get VM IP from state using network-aware resolution
    base_dir="${STATE_BASE_DIR:-$HOME/.config/tfgrid-compose/state}"

    # Resolve app name to deployment ID via registry with enhanced resolution
    RESOLVED_DEPLOYMENT=$(resolve_deployment "$APP_NAME" 2>/dev/null)
    RESOLVE_RESULT=$?

    case $RESOLVE_RESULT in
        0)
            # Single match found
            DEPLOYMENT_ID="$RESOLVED_DEPLOYMENT"
            ;;
        3)
            # Multiple matches - show selection menu
            echo ""
            echo "üì± Multiple deployments found for: $APP_NAME"
            echo ""

            # Parse ambiguous results and show options
            local IFS=$'\n'
            local options=($RESOLVED_DEPLOYMENT)
            local deployment_info=()

            for i in "${!options[@]}"; do
                local deployment_id="${options[$i]}"
                local details=$(get_deployment_by_id "$deployment_id" 2>/dev/null)

                if [ -n "$details" ]; then
                    local app_name=$(echo "$details" | grep "app_name:" | awk '{print $2}')
                    local vm_ip=$(echo "$details" | grep "vm_ip:" | awk '{print $2}')
                    local created_at=$(echo "$details" | grep "created_at:" | awk '{print $2}')
                    local age=$(calculate_deployment_age "$created_at" 2>/dev/null || echo "unknown")

                    echo "$((i+1))) $deployment_id $app_name ($vm_ip) - $age"
                    deployment_info+=("$deployment_id")
                fi
            done

            echo ""
            read -p "Select deployment [1-${#options[@]}]: " choice

            # Validate choice
            if ! [[ "$choice" =~ ^[0-9]+$ ]] || [ "$choice" -lt 1 ] || [ "$choice" -gt ${#options[@]} ]; then
                log_error "Invalid choice"
                return 1
            fi

            # Get selected deployment
            DEPLOYMENT_ID="${deployment_info[$((choice-1))]}"
            echo ""
            local details=$(get_deployment_by_id "$DEPLOYMENT_ID" 2>/dev/null)
            if [ -n "$details" ]; then
                local app_name=$(echo "$details" | grep "app_name:" | awk '{print $2}')
                local vm_ip=$(echo "$details" | grep "vm_ip:" | awk '{print $2}')
                log_success "‚úÖ Selected $DEPLOYMENT_ID ($app_name) - VM: $vm_ip"
            else
                log_success "‚úÖ Selected $DEPLOYMENT_ID"
            fi
            ;;
        *)
            # No matches found
            log_error "No deployment found for: $APP_NAME"
            log_info "Deploy first with: tfgrid-compose up $APP_NAME"
            log_info "Or use 'tfgrid-compose ps' to see available deployments"
            return 1
            ;;
    esac

    state_dir="$base_dir/$DEPLOYMENT_ID"

    if [ ! -d "$state_dir" ]; then
        log_error "Deployment state not found (inconsistent state)"
        log_info "Try redeploying: tfgrid-compose up $APP_NAME --force"
        return 1
    fi

    # Use network-aware IP resolution instead of direct vm_ip lookup
    vm_ip=$(get_deployment_ip "$DEPLOYMENT_ID")

    if [ -z "$vm_ip" ]; then
        log_error "No IP found in state for $APP_NAME"
        return 1
    fi
    
    # Check if this command should save to context
    MANIFEST="$APP_PATH/tfgrid-compose.yaml"
    SAVE_TO_CONTEXT=$(grep -A 5 "^  $command:" "$MANIFEST" 2>/dev/null | grep "save_to_context:" | awk '{print $2}')
    
    # Check if this command needs TTY allocation (defaults to true for backwards compatibility)
    ALLOCATE_TTY=$(grep -A 5 "^  $command:" "$MANIFEST" 2>/dev/null | grep "allocate_tty:" | awk '{print $2}')
    if [ -z "$ALLOCATE_TTY" ]; then
        ALLOCATE_TTY="true"  # Default to true for backwards compatibility
    fi
    
    # Execute command on VM
    log_info "Executing '$command' on $APP_NAME ($vm_ip)"
    echo ""
    
    if [ -n "$SAVE_TO_CONTEXT" ]; then
        # Capture output to save to context
        OUTPUT=$(ssh -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null -o LogLevel=ERROR \
            root@$vm_ip "APP_NAME=$APP_NAME $SCRIPT_PATH $args" 2>/dev/null)
        RESULT=$?
        
        if [ $RESULT -eq 0 ] && [ -n "$OUTPUT" ]; then
            # Save to context file
            CONTEXT_FILE="$HOME/.config/tfgrid-compose/context.yaml"
            mkdir -p "$(dirname "$CONTEXT_FILE")"
            
            # Remove old value if exists
            if [ -f "$CONTEXT_FILE" ]; then
                sed -i "/^$SAVE_TO_CONTEXT:/d" "$CONTEXT_FILE"
            fi
            
            # Add new value
            echo "$SAVE_TO_CONTEXT: $OUTPUT" >> "$CONTEXT_FILE"
            
            log_success "Selected $command: $OUTPUT"
        fi
        
        return $RESULT
    else
        # Conditionally allocate TTY based on metadata
        if [ "$ALLOCATE_TTY" = "true" ]; then
            # Use -t to allocate TTY for interactive commands that need it
            ssh -t -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null -o LogLevel=ERROR \
                root@$vm_ip "APP_NAME=$APP_NAME $SCRIPT_PATH $args"
        else
            # Don't allocate TTY for commands that start background services
            ssh -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null -o LogLevel=ERROR \
                root@$vm_ip "APP_NAME=$APP_NAME $SCRIPT_PATH $args"
        fi
        
        return $?
    fi
}

# Resolve app input to path (handles both registry names and local paths)
resolve_app_path() {
    local app_input="$1"
    local quiet="${2:-false}"
    
    if [ -z "$app_input" ]; then
        return 1
    fi
    
    # If it's a path (contains / or starts with .), return as-is
    if [[ "$app_input" == */* ]] || [[ "$app_input" == .* ]]; then
        echo "$app_input"
        return 0
    fi
    
    # Check if it's a deployment ID - get deployment details and use state_dir
    local deployment_details=$(get_deployment_by_id "$app_input" 2>/dev/null || echo "")
    if [ -n "$deployment_details" ]; then
        # It's a deployment ID - get the state_dir
        local state_dir=""
        if command_exists yq; then
            state_dir=$(echo "$deployment_details" | yq eval '.state_dir // empty' - 2>/dev/null || echo "")
        else
            state_dir=$(echo "$deployment_details" | grep "state_dir:" | awk '{print $2}' | tr -d '"' || echo "")
        fi
        
        if [ -n "$state_dir" ] && [ "$state_dir" != "empty" ] && [ -d "$state_dir" ]; then
            echo "$state_dir"
            return 0
        fi
    fi
    
    # Try to find existing deployment by app name
    local deployment_id=$(get_active_deployment_for_app "$app_input" 2>/dev/null || echo "")
    if [ -n "$deployment_id" ]; then
        # Found deployment - get its state_dir
        local deployment_details=$(get_deployment_by_id "$deployment_id" 2>/dev/null || echo "")
        if [ -n "$deployment_details" ]; then
            local state_dir=""
            if command_exists yq; then
                state_dir=$(echo "$deployment_details" | yq eval '.state_dir // empty' - 2>/dev/null || echo "")
            else
                state_dir=$(echo "$deployment_details" | grep "state_dir:" | awk '{print $2}' | tr -d '"' || echo "")
            fi
            
            if [ -n "$state_dir" ] && [ "$state_dir" != "empty" ] && [ -d "$state_dir" ]; then
                echo "$state_dir"
                return 0
            fi
        fi
    fi
    
    # No deployment found - treat as registry app name
    local app_name="$app_input"
    local cached_path="$APP_CACHE_DIR/$app_name"
    
    if [ -d "$cached_path" ]; then
        echo "$cached_path"
        return 0
    fi
    
    # Not cached - try to download
    if [ "$quiet" != "true" ]; then
        log_info "Looking up $app_name in registry..."
    fi
    
    local repo_url=$(get_app_repo "$app_name")
    if [ -z "$repo_url" ]; then
        if [ "$quiet" != "true" ]; then
            log_error "App '$app_name' not found in registry"
            log_info "Available deployments:"
            list_deployments 2>/dev/null || true
        fi
        return 1
    fi
    
    local app_path=$(get_app "$app_name" "$repo_url")
    if [ -z "$app_path" ]; then
        return 1
    fi
    
    echo "$app_path"
    return 0
}

# Parse global flags
while [[ $# -gt 0 ]]; do
    case "$1" in
        -f|--file)
            MANIFEST_FILE="$2"
            shift 2
            ;;
        *)
            break
            ;;
    esac
done

# Export manifest file for other modules
export APP_MANIFEST_FILE="$MANIFEST_FILE"

# Command dispatcher
COMMAND="${1:-help}"
shift || true

# Handle commands
case "$COMMAND" in
    --version|version|-v)
        echo "TFGrid Compose $VERSION"
        if [ "$GIT_COMMIT" != "unknown" ] && [ "$SEMANTIC_VERSION" != "unknown" ] && [ "$GIT_COMMIT" != "$SEMANTIC_VERSION" ]; then
            echo "Semantic version: $SEMANTIC_VERSION"
        fi
        exit 0
        ;;
    
    search)
        # Search registry
        log_command "Search Registry"
        
        QUERY="${1:-}"
        TAG="${2:-}"
        
        if [ -n "$TAG" ] && [ "$1" = "--tag" ]; then
            TAG="$2"
            QUERY=""
        fi
        
        log_info "Available apps:"
        echo ""
        
        if ! search_registry "$QUERY" "$TAG"; then
            log_error "Failed to search registry"
            exit 1
        fi
        
        echo ""
        log_info "Deploy an app: tfgrid-compose up <app-name>"
        log_info "Multi-deploy: tfgrid-compose up <app> --name=<suffix>"
        exit 0
        ;;
    
    list)
        # List deployed apps with Docker-style integration
        log_info "TFGrid Compose v$VERSION - Deployed Apps"
        echo ""
        
        # Try Docker-style listing first
        if list_deployments_docker_style >/dev/null 2>&1; then
            echo "Docker-style deployments:"
            echo ""
            list_deployments_docker_style
            echo ""
            
            # Show smart context info for Docker-style deployments
            SMART_CTX=$(get_smart_context)
            CURRENT=$(get_current_app)
            
            if [ -n "$SMART_CTX" ] && [ -z "$CURRENT" ]; then
                log_info "Using '$SMART_CTX' as default (only deployment active)"
            elif [ -n "$CURRENT" ]; then
                log_info "Active context: $CURRENT"
                log_info "Change with: tfgrid-compose select"
            else
                log_info "Select a deployment: tfgrid-compose select"
                log_info "Run commands: tfgrid-compose <command> [args]"
            fi
        else
            # Fallback to legacy app-based listing
            if ! list_deployed_apps; then
                log_warning "No apps deployed"
                echo ""
                log_info "Deploy an app: tfgrid-compose up <app-name>"
                log_info "Multi-deploy: tfgrid-compose up <app> --name=<suffix>"
            else
                echo ""
                # Show smart context info
                SMART_CTX=$(get_smart_context)
                CURRENT=$(get_current_app)
                
                if [ -n "$SMART_CTX" ] && [ -z "$CURRENT" ]; then
                    log_info "Using '$SMART_CTX' as default (only app deployed)"
                elif [ -n "$CURRENT" ]; then
                    log_info "Active context: $CURRENT"
                    log_info "Change with: tfgrid-compose select"
                fi
            fi
        fi
        
        ;;
        
    ps)
        # Docker-style process listing
        log_info "TFGrid Compose v$VERSION - Docker-Style Deployment Listing"
        echo ""
        
        if list_deployments_docker_style >/dev/null 2>&1; then
            list_deployments_docker_style
            echo ""
            log_info "Select deployment: tfgrid-compose select <deployment-id|app-name>"
            log_info "Run commands: tfgrid-compose <command> [args]"
        else
            log_warning "No deployments found"
            echo ""
            log_info "Deploy an app: tfgrid-compose up <app-name>"
        fi
        
        exit 0
        ;;
    
    select)
        # Select active app with multi-deployment support
        APP_NAME="$1"
        
        if [ -z "$APP_NAME" ]; then
            # Interactive selection
            base_dir="${STATE_BASE_DIR:-$HOME/.config/tfgrid-compose/state}"
            
            # Quick check: use Docker-style deployment registry instead of just state directories
            all_deployments=$(get_all_deployments 2>/dev/null || echo "")
            
            # Quick check: if no deployments in registry, show error immediately
            if [ -z "$all_deployments" ]; then
                echo ""
                echo "üì± Select deployment:"
                echo ""
                log_error "No deployments available for selection"
                echo ""
                log_info "No deployments found"
                echo ""
                log_info "Deploy an app: tfgrid-compose up <app-name>"
                echo ""
                exit 1
            fi
            
            # Build array of deployments for selection
            DEPLOYMENTS=()
            DEPLOYMENT_OPTIONS=()
            i=1
            
            # Get all deployments from registry
            all_deployments=$(get_all_deployments 2>/dev/null || echo "")
            
            if [ -n "$all_deployments" ] && command_exists yq; then
                # Use enhanced deployment listing with timestamps (include contract_id)
                while IFS='|' read -r deployment_id app_name vm_ip contract_id status created_at; do
                    # Skip if deployment details not available
                    if [ -z "$deployment_id" ] || [ -z "$app_name" ]; then
                        continue
                    fi
                    
                    # Skip orphaned deployments - only include those with contract IDs
                    if [ -z "$contract_id" ] || [ "$contract_id" = "null" ]; then
                        log_debug "Skipping orphaned deployment (no contract): $deployment_id"
                        continue
                    fi
                    
                    # Check if deployment state exists
                    state_dir="$base_dir/$deployment_id"
                    if [ ! -d "$state_dir" ]; then
                        log_debug "Skipping deployment with missing state: $deployment_id"
                        continue
                    fi
                    
                    # PRIORITY: Only include deployments with valid contracts in selection
                    # Skip orphaned deployments even if they have VM IPs
                    if [ -n "$contract_id" ] && [ "$contract_id" != "null" ] && [ "$contract_id" != "" ]; then
                        # Validate contract exists on grid
                        if [ "$(validate_deployment_contracts "$deployment_id" 2>/dev/null)" = "true" ]; then
                            # This deployment has a valid contract - include it
                            DEPLOYMENTS+=("$deployment_id")
                            
                            # Calculate age for display
                            age=$(calculate_deployment_age "$created_at" 2>/dev/null || echo "unknown")
                            
                            # Format deployment option
                            option="$i) $deployment_id $app_name ($vm_ip) - $age"
                            DEPLOYMENT_OPTIONS+=("$option")
                            
                            # Mark if currently selected
                            CURRENT_APP_FILE="$HOME/.config/tfgrid-compose/current-app"
                            if [ -f "$CURRENT_APP_FILE" ] && [ "$(cat "$CURRENT_APP_FILE")" = "$deployment_id" ]; then
                                DEPLOYMENT_OPTIONS[$((i-1))]="${DEPLOYMENT_OPTIONS[$((i-1))]} ‚Üê (currently selected)"
                            fi
                            
                            ((i++))
                        else
                            log_debug "Skipping deployment with invalid/cancelled contract: $deployment_id (contract: $contract_id)"
                        fi
                    fi
                done <<< "$all_deployments"
            else
                # Fallback to old app-based selection
                for app_dir in "$base_dir"/*; do
                    if [ -d "$app_dir" ]; then
                        app=$(basename "$app_dir")
                        
                        # Check if deployment is healthy and should be included in selection
                        if timeout 5 validate_deployment_for_context "$app" 2>/dev/null; then
                            DEPLOYMENTS+=("$app")
                            
                            # Get VM IP if available
                            vm_ip=$(grep "^vm_ip:" "$app_dir/state.yaml" 2>/dev/null | awk '{print $2}' || echo "")
                            
                            # Get deployment status for display
                            status=$(check_deployment_status "$app")
                            
                            option="$i) $app ($vm_ip) [$status]"
                            DEPLOYMENT_OPTIONS+=("$option")
                            
                            # Check if currently selected
                            CURRENT_APP_FILE="$HOME/.config/tfgrid-compose/current-app"
                            if [ -f "$CURRENT_APP_FILE" ] && [ "$(cat "$CURRENT_APP_FILE")" = "$app" ]; then
                                DEPLOYMENT_OPTIONS[$((i-1))]="${DEPLOYMENT_OPTIONS[$((i-1))]} ‚Üê (currently selected)"
                            fi
                            
                            ((i++))
                        else
                            log_debug "Skipping unhealthy deployment: $app"
                        fi
                    fi
                done
            fi
            
            # Check if any valid deployments found
            if [ ${#DEPLOYMENTS[@]} -eq 0 ]; then
                echo ""
                echo "üì± Select deployment:"
                echo ""
                
                # Check if there are any deployments in the registry at all
                any_deployments=$(get_all_deployments 2>/dev/null || echo "")
                if [ -z "$any_deployments" ]; then
                    log_error "No deployments found"
                else
                    # There are deployments but they failed validation - list them
                    echo "‚ö†Ô∏è  Some deployments exist but may be unhealthy:"
                    echo ""
                    
                    # Show deployments from registry that have active contracts but failed other validation
                    if command_exists yq; then
                        while IFS='|' read -r deployment_id app_name vm_ip contract_id status created_at; do
                            # Only show deployments with ACTIVE contracts on the grid
                            if [ -n "$deployment_id" ] && [ -n "$contract_id" ] && [ "$contract_id" != "null" ] && [ "$contract_id" != "" ]; then
                                # Validate contract exists on grid
                                if [ "$(validate_deployment_contracts "$deployment_id" 2>/dev/null)" = "true" ]; then
                                    age=$(calculate_deployment_age "$created_at" 2>/dev/null || echo "unknown")
                                    status_emoji="‚ùì"
                                    case "$status" in
                                        "active") status_emoji="‚úÖ" ;;
                                        "failed") status_emoji="‚ùå" ;;
                                        "deploying") status_emoji="‚è≥" ;;
                                    esac
                                    echo "$status_emoji $deployment_id $app_name ($vm_ip) - $age"
                                fi
                            fi
                        done <<< "$any_deployments"
                    fi
                    
                    echo ""
                    log_info "These deployments failed health validation"
                    log_info "Check status with: tfgrid-compose ps"
                fi
                
                echo ""
                log_info "Deploy an app: tfgrid-compose up <app-name>"
                echo ""
                exit 1
            fi
            
            # Print header and available deployments
            echo ""
            echo "üì± Select deployment:"
            echo ""
            for option in "${DEPLOYMENT_OPTIONS[@]}"; do
                echo "$option"
            done
            
            echo ""
            read -p "Enter number [1-${#DEPLOYMENTS[@]}] or 'q' to quit: " choice
            
            if [ "$choice" = "q" ] || [ "$choice" = "Q" ]; then
                echo ""
                log_info "Cancelled"
                exit 0
            fi
            
            # Validate choice
            if ! [[ "$choice" =~ ^[0-9]+$ ]] || [ "$choice" -lt 1 ] || [ "$choice" -gt ${#DEPLOYMENTS[@]} ]; then
                echo ""
                log_error "Invalid choice"
                exit 1
            fi
            
            # Get selected deployment (arrays are 0-indexed)
            APP_NAME="${DEPLOYMENTS[$((choice-1))]}"
        else
            # Direct selection - resolve identifier with smart matching
            RESOLVED_DEPLOYMENT=$(resolve_deployment "$APP_NAME" 2>/dev/null)
            RESOLVE_RESULT=$?
            
            case $RESOLVE_RESULT in
                0)
                    # Single match found
                    APP_NAME="$RESOLVED_DEPLOYMENT"
                    ;;
                3)
                    # Multiple matches - show selection menu
                    echo ""
                    echo "üì± Select deployment:"
                    echo ""
                    
                    # Parse ambiguous results and show options
                    IFS=$'\n'
                    options=($RESOLVED_DEPLOYMENT)
                    deployment_info=()
                    
                    for i in "${!options[@]}"; do
                        deployment_id="${options[$i]}"
                        details=$(get_deployment_by_id "$deployment_id" 2>/dev/null)
                        
                        if [ -n "$details" ]; then
                            app_name=$(echo "$details" | grep "app_name:" | awk '{print $2}')
                            vm_ip=$(echo "$details" | grep "vm_ip:" | awk '{print $2}')
                            created_at=$(echo "$details" | grep "created_at:" | awk '{print $2}')
                            age=$(calculate_deployment_age "$created_at" 2>/dev/null || echo "unknown")
                            
                            echo "$((i+1))) $deployment_id $app_name ($vm_ip) - $age"
                            deployment_info+=("$deployment_id")
                        fi
                    done
                    
                    echo ""
                    read -p "Enter number [1-${#options[@]}] or 'q' to quit: " choice
                    
                    if [ "$choice" = "q" ] || [ "$choice" = "Q" ]; then
                        echo ""
                        log_info "Cancelled"
                        exit 0
                    fi
                    
                    # Validate choice
                    if ! [[ "$choice" =~ ^[0-9]+$ ]] || [ "$choice" -lt 1 ] || [ "$choice" -gt ${#options[@]} ]; then
                        echo ""
                        log_error "Invalid choice"
                        exit 1
                    fi
                    
                    # Get selected deployment
                    APP_NAME="${deployment_info[$((choice-1))]}"
                    ;;
                *)
                    # No matches found
                    log_error "Deployment not found: $APP_NAME"
                    echo ""
                    log_info "Use 'tfgrid-compose ps' to see available deployments"
                    exit 1
                    ;;
            esac
        fi
        
        if set_current_app "$APP_NAME"; then
            echo ""
            
            # Get deployment details for confirmation
            details=$(get_deployment_by_id "$APP_NAME" 2>/dev/null)
            if [ -n "$details" ]; then
                app_name=$(echo "$details" | grep "app_name:" | awk '{print $2}')
                vm_ip=$(echo "$details" | grep "vm_ip:" | awk '{print $2}')
                created_at=$(echo "$details" | grep "created_at:" | awk '{print $2}')
                age=$(calculate_deployment_age "$created_at" 2>/dev/null || echo "unknown")
                
                log_success "Selected $APP_NAME $app_name"
                log_info "VM: $vm_ip | Age: $age"
            else
                log_success "Selected $APP_NAME"
            fi
            
            log_info "Deployment-specific commands will now take precedence"
            echo ""
        else
            exit 1
        fi
        
        exit 0
        ;;
        
    unselect)
        # Unselect active app
        CURRENT_APP_FILE="$HOME/.config/tfgrid-compose/current-app"
        if [ -f "$CURRENT_APP_FILE" ]; then
            CURRENT=$(cat "$CURRENT_APP_FILE")
            rm "$CURRENT_APP_FILE"
            log_success "Unselected $CURRENT"
            log_info "Built-in commands will now be used"
        else
            log_info "No app currently selected"
        fi
        exit 0
        ;;
    
    unselect-project)
        # Unselect active project
        CONTEXT_FILE="$HOME/.config/tfgrid-compose/context.yaml"
        if [ -f "$CONTEXT_FILE" ]; then
            # Remove active_project line from context
            sed -i '/^active_project:/d' "$CONTEXT_FILE"
            log_success "Cleared project selection"
        else
            log_info "No project currently selected"
        fi
        exit 0
        ;;
        
    dashboard)
        # Start local web dashboard (Phase 1)
        DASHBOARD_HOME="$HOME/.config/tfgrid-compose/dashboard"
        DASHBOARD_SERVER="$DASHBOARD_HOME/server.js"
        DASHBOARD_PID_FILE="$DASHBOARD_HOME/dashboard.pid"
        DASHBOARD_PORT_FILE="$DASHBOARD_HOME/dashboard-port"
        DASHBOARD_ACTION="$1"

        # If no explicit action is provided and a background dashboard is already running,
        # report its status instead of starting another instance.
        if [ -z "$DASHBOARD_ACTION" ] && [ -f "$DASHBOARD_PID_FILE" ]; then
            DASHBOARD_PID=$(cat "$DASHBOARD_PID_FILE" 2>/dev/null || true)
            if [ -n "$DASHBOARD_PID" ] && ps -p "$DASHBOARD_PID" >/dev/null 2>&1; then
                DASHBOARD_PORT=""
                if [ -f "$DASHBOARD_PORT_FILE" ]; then
                    DASHBOARD_PORT=$(cat "$DASHBOARD_PORT_FILE" 2>/dev/null || true)
                fi
                if [ -n "$DASHBOARD_PORT" ]; then
                    log_info "Dashboard already running at http://localhost:$DASHBOARD_PORT (pid $DASHBOARD_PID)"
                else
                    log_info "Dashboard already running (pid $DASHBOARD_PID)"
                fi
                exit 0
            else
                rm -f "$DASHBOARD_PID_FILE"
            fi
        fi

        if [ "$DASHBOARD_ACTION" = "stop" ]; then
            if [ -f "$DASHBOARD_PID_FILE" ]; then
                DASHBOARD_PID=$(cat "$DASHBOARD_PID_FILE" 2>/dev/null || true)
                if [ -n "$DASHBOARD_PID" ] && ps -p "$DASHBOARD_PID" >/dev/null 2>&1; then
                    kill "$DASHBOARD_PID" 2>/dev/null || true
                    for i in $(seq 1 50); do
                        if ! ps -p "$DASHBOARD_PID" >/dev/null 2>&1; then
                            break
                        fi
                        sleep 0.1
                    done
                    log_success "Stopped dashboard (pid $DASHBOARD_PID)"
                else
                    log_info "Dashboard is not running"
                fi
                rm -f "$DASHBOARD_PID_FILE"
            else
                log_info "Dashboard is not running"
            fi
            exit 0
        fi

        if [ "$DASHBOARD_ACTION" = "status" ]; then
            if [ -f "$DASHBOARD_PID_FILE" ]; then
                DASHBOARD_PID=$(cat "$DASHBOARD_PID_FILE" 2>/dev/null || true)
                if [ -n "$DASHBOARD_PID" ] && ps -p "$DASHBOARD_PID" >/dev/null 2>&1; then
                    DASHBOARD_PORT=""
                    if [ -f "$DASHBOARD_PORT_FILE" ]; then
                        DASHBOARD_PORT=$(cat "$DASHBOARD_PORT_FILE" 2>/dev/null || true)
                    fi
                    if [ -n "$DASHBOARD_PORT" ]; then
                        log_info "Dashboard running at http://localhost:$DASHBOARD_PORT (pid $DASHBOARD_PID)"
                    else
                        log_info "Dashboard running (pid $DASHBOARD_PID)"
                    fi
                    exit 0
                else
                    log_info "Dashboard is not running"
                    rm -f "$DASHBOARD_PID_FILE"
                    exit 0
                fi
            else
                log_info "Dashboard is not running"
                exit 0
            fi
        fi

        if [ "$DASHBOARD_ACTION" = "logs" ]; then
            DASHBOARD_LOG_FILE="$DASHBOARD_HOME/dashboard.log"
            if [ ! -f "$DASHBOARD_LOG_FILE" ]; then
                log_info "No dashboard log file found at $DASHBOARD_LOG_FILE"
                exit 0
            fi

            tail -n 200 -f "$DASHBOARD_LOG_FILE"
            exit $?
        fi

        if [ "$DASHBOARD_ACTION" = "desktop" ]; then
            # Install or refresh a desktop launcher for the dashboard (idempotent)
            LAUNCHER_DIR="$HOME/.local/bin"
            LAUNCHER_PATH="$LAUNCHER_DIR/tfgrid-dashboard-launcher"
            APPLICATIONS_DIR="$HOME/.local/share/applications"
            DESKTOP_FILE="$APPLICATIONS_DIR/tfgrid-dashboard.desktop"
            DESKTOP_DIR="$HOME/Desktop"

            mkdir -p "$LAUNCHER_DIR" "$APPLICATIONS_DIR"

            cat >"$LAUNCHER_PATH" <<'EOF'
#!/usr/bin/env bash
set -e

# Ensure dashboard is running in background
tfgrid-compose dashboard start >/dev/null 2>&1 || true

DASHBOARD_HOME="$HOME/.config/tfgrid-compose/dashboard"
DASHBOARD_PORT_FILE="$DASHBOARD_HOME/dashboard-port"
PORT="${TFGRID_DASHBOARD_PORT:-3000}"

if [ -f "$DASHBOARD_PORT_FILE" ]; then
  P=$(cat "$DASHBOARD_PORT_FILE" 2>/dev/null || true)
  if [ -n "$P" ]; then
    PORT="$P"
  fi
fi

URL="http://localhost:$PORT"

launch_app_window() {
  local url="$1"

  # Prefer Brave/Chromium in a dedicated incognito window with the dashboard URL
  if command -v brave-browser >/dev/null 2>&1; then
    brave-browser --incognito --new-window "$url" >/dev/null 2>&1 &
    return
  fi

  if command -v brave-browser-stable >/dev/null 2>&1; then
    brave-browser-stable --incognito --new-window "$url" >/dev/null 2>&1 &
    return
  fi

  if command -v brave >/dev/null 2>&1; then
    brave --incognito --new-window "$url" >/dev/null 2>&1 &
    return
  fi

  if command -v google-chrome >/dev/null 2>&1; then
    google-chrome --incognito --new-window "$url" >/dev/null 2>&1 &
    return
  fi

  if command -v google-chrome-stable >/dev/null 2>&1; then
    google-chrome-stable --incognito --new-window "$url" >/dev/null 2>&1 &
    return
  fi

  if command -v chromium >/dev/null 2>&1; then
    chromium --incognito --new-window "$url" >/dev/null 2>&1 &
    return
  fi

  if command -v chromium-browser >/dev/null 2>&1; then
    chromium-browser --incognito --new-window "$url" >/dev/null 2>&1 &
    return
  fi

  # Fallback to system default browser
  if command -v xdg-open >/dev/null 2>&1; then
    xdg-open "$url" >/dev/null 2>&1 &
  else
    echo "Open $url in your browser"
  fi
}

launch_app_window "$URL"
EOF

            chmod +x "$LAUNCHER_PATH"

            # Try to install an icon from the bundled favicon, if available
            ICON_NAME="tfgrid-studio-dashboard"
            ICON_TARGET_DIR="$HOME/.local/share/icons"
            ICON_PATH="$ICON_TARGET_DIR/$ICON_NAME.svg"
            TEMPLATE_DIR="$DEPLOYER_ROOT/dashboard"
            FAVICON_SOURCE="$TEMPLATE_DIR/public/favicon.svg"

            if [ -f "$FAVICON_SOURCE" ]; then
                mkdir -p "$ICON_TARGET_DIR"
                cp "$FAVICON_SOURCE" "$ICON_PATH" 2>/dev/null || true
            fi

            cat >"$DESKTOP_FILE" <<EOF
[Desktop Entry]
Type=Application
Name=TFGrid Studio Dashboard
Comment=Local dashboard for tfgrid-compose apps and deployments
Exec=$LAUNCHER_PATH
Terminal=false
Icon=$ICON_NAME
Categories=Development;Network;
EOF

            # Mark the desktop entry as executable so some desktop environments treat it as a launcher
            chmod +x "$DESKTOP_FILE" 2>/dev/null || true

            # Optionally place a shortcut on the user's Desktop if it exists
            if [ -d "$DESKTOP_DIR" ]; then
                DESKTOP_SHORTCUT="$DESKTOP_DIR/TFGrid Studio Dashboard.desktop"
                cp "$DESKTOP_FILE" "$DESKTOP_SHORTCUT" 2>/dev/null || true
                chmod +x "$DESKTOP_SHORTCUT" 2>/dev/null || true
            fi

            echo ""
            log_success "TFGrid Studio Dashboard desktop launcher installed."
            echo ""
            log_info "Launcher script: $LAUNCHER_PATH"
            log_info "Menu entry: TFGrid Studio Dashboard (under Applications/Development)"
            if [ -d "$DESKTOP_DIR" ]; then
                log_info "Desktop icon: $DESKTOP_DIR/TFGrid Studio Dashboard.desktop"
            fi
            echo ""
            exit 0
        fi

        # Bootstrap or refresh dashboard code into config directory from installed template
        TEMPLATE_DIR="$DEPLOYER_ROOT/dashboard"

        if [ -d "$TEMPLATE_DIR" ]; then
            mkdir -p "$(dirname "$DASHBOARD_HOME")"
            if [ ! -d "$DASHBOARD_HOME" ]; then
                cp -R "$TEMPLATE_DIR" "$DASHBOARD_HOME"
            else
                # Refresh core dashboard files while preserving node_modules
                if [ -f "$TEMPLATE_DIR/server.js" ]; then
                    cp "$TEMPLATE_DIR/server.js" "$DASHBOARD_HOME/server.js"
                fi
                if [ -d "$TEMPLATE_DIR/public" ]; then
                    rm -rf "$DASHBOARD_HOME/public"
                    cp -R "$TEMPLATE_DIR/public" "$DASHBOARD_HOME/public"
                fi
            fi
        else
            log_error "Dashboard template not found at $TEMPLATE_DIR"
            echo ""
            echo "Reinstall tfgrid-compose or run the dashboard from a full tfgrid-studio checkout."
            exit 1
        fi

        # Install dependencies if needed
        if [ ! -d "$DASHBOARD_HOME/node_modules" ]; then
            if ! command -v npm >/dev/null 2>&1; then
                log_error "npm is required to install dashboard dependencies"
                echo "Install Node.js (v18+) and npm, then run:"
                echo "  cd $DASHBOARD_HOME && npm install"
                exit 1
            fi

            log_info "Installing dashboard dependencies (npm install)..."
            (
                cd "$DASHBOARD_HOME"
                npm install
            )
        fi

        if ! command -v node >/dev/null 2>&1; then
            log_error "Node.js is required to run the dashboard backend"
            echo "Install Node.js (v18+), then run:"
            echo "  tfgrid-compose dashboard"
            exit 1
        fi

        if [ "$DASHBOARD_ACTION" = "start" ]; then
            if [ -f "$DASHBOARD_PID_FILE" ]; then
                DASHBOARD_PID=$(cat "$DASHBOARD_PID_FILE" 2>/dev/null || true)
                if [ -n "$DASHBOARD_PID" ] && ps -p "$DASHBOARD_PID" >/dev/null 2>&1; then
                    DASHBOARD_PORT=""
                    if [ -f "$DASHBOARD_PORT_FILE" ]; then
                        DASHBOARD_PORT=$(cat "$DASHBOARD_PORT_FILE" 2>/dev/null || true)
                    fi
                    if [ -n "$DASHBOARD_PORT" ]; then
                        log_info "Dashboard already running at http://localhost:$DASHBOARD_PORT (pid $DASHBOARD_PID)"
                    else
                        log_info "Dashboard already running (pid $DASHBOARD_PID)"
                    fi
                    exit 0
                else
                    rm -f "$DASHBOARD_PID_FILE"
                fi
            fi

            log_info "Starting TFGrid Studio local dashboard in background..."
            TFGRID_DASHBOARD_PORT="${TFGRID_DASHBOARD_PORT:-3000}" \
            TFGRID_COMPOSE_BIN="${TFGRID_COMPOSE_BIN:-tfgrid-compose}" \
            TFGRID_COMMANDS_SCHEMA="$DEPLOYER_ROOT/core/commands-schema.json" \
            node "$DASHBOARD_SERVER" >"$DASHBOARD_HOME/dashboard.log" 2>&1 &
            DASHBOARD_PID=$!
            echo "$DASHBOARD_PID" >"$DASHBOARD_PID_FILE"

            DASHBOARD_PORT=""
            for i in $(seq 1 50); do
                if [ -f "$DASHBOARD_PORT_FILE" ]; then
                    DASHBOARD_PORT=$(cat "$DASHBOARD_PORT_FILE" 2>/dev/null || true)
                    if [ -n "$DASHBOARD_PORT" ]; then
                        break
                    fi
                fi
                sleep 0.1
            done

            if [ -z "$DASHBOARD_PORT" ]; then
                DASHBOARD_PORT="${TFGRID_DASHBOARD_PORT:-3000}"
            fi

            log_success "Dashboard started at http://localhost:$DASHBOARD_PORT (pid $DASHBOARD_PID)"
            exit 0
        fi

        log_info "Starting TFGrid Studio local dashboard..."
        echo ""
        echo "Dashboard base URL: http://localhost:${TFGRID_DASHBOARD_PORT:-3000}"
        echo ""

        TFGRID_DASHBOARD_PORT="${TFGRID_DASHBOARD_PORT:-3000}" \
        TFGRID_COMPOSE_BIN="${TFGRID_COMPOSE_BIN:-tfgrid-compose}" \
        TFGRID_COMMANDS_SCHEMA="$DEPLOYER_ROOT/core/commands-schema.json" \
        node "$DASHBOARD_SERVER"
        exit $?
        ;;

    commands)
        # Show app-specific commands for selected app
        CURRENT_APP=$(get_current_app)
        
        if [ -z "$CURRENT_APP" ]; then
            log_error "No app selected"
            echo ""
            log_info "Select an app first: tfgrid-compose select"
            exit 1
        fi
        
        # Resolve app path
        APP_PATH=$(resolve_app_path "$CURRENT_APP")
        if [ -z "$APP_PATH" ] || [ ! -f "$APP_PATH/tfgrid-compose.yaml" ]; then
            log_error "Cannot find app: $CURRENT_APP"
            exit 1
        fi
        
        echo ""
        echo "üìã Commands for $CURRENT_APP:"
        echo ""
        
        # Parse commands section with sed/grep (compatible approach)
        in_commands=false
        current_cmd=""
        current_desc=""
        current_args=""
        
        while IFS= read -r line; do
            # Check if entering commands section
            if [[ "$line" == "commands:" ]]; then
                in_commands=true
                continue
            fi
            
            # Exit if we hit another top-level section
            if [ "$in_commands" = true ] && [[ "$line" =~ ^[a-z] ]]; then
                break
            fi
            
            # Parse command entries (2-space indent)
            if [ "$in_commands" = true ]; then
                if [[ "$line" =~ ^[[:space:]]{2}([a-z_-]+):$ ]]; then
                    # Print previous command if exists
                    if [ -n "$current_cmd" ]; then
                        if [ -n "$current_args" ]; then
                            printf "  ${GREEN}%-15s${NC} %s %s\n" "$current_cmd" "$current_args" "$current_desc"
                        else
                            printf "  ${GREEN}%-15s${NC} %s\n" "$current_cmd" "$current_desc"
                        fi
                    fi
                    
                    # Start new command
                    current_cmd="${BASH_REMATCH[1]}"
                    current_desc=""
                    current_args=""
                    
                elif [[ "$line" =~ ^[[:space:]]{4}description:[[:space:]]*(.+)$ ]]; then
                    current_desc="${BASH_REMATCH[1]}"
                    
                elif [[ "$line" =~ ^[[:space:]]{4}args:[[:space:]]*(.+)$ ]]; then
                    current_args="${BASH_REMATCH[1]}"
                fi
            fi
        done < "$APP_PATH/tfgrid-compose.yaml"
        
        # Print last command
        if [ -n "$current_cmd" ]; then
            if [ -n "$current_args" ]; then
                printf "  ${GREEN}%-15s${NC} %s %s\n" "$current_cmd" "$current_args" "$current_desc"
            else
                printf "  ${GREEN}%-15s${NC} %s\n" "$current_cmd" "$current_desc"
            fi
        fi
        
        echo ""
        log_info "Run commands with: tfgrid-compose <command> [args]"
        echo ""
        exit 0
        ;;
        
    up)
        # Deploy command
        log_command "Deploy Application"
        
        # Validate prerequisites
        if ! validate_prerequisites; then
            exit 1
        fi
        echo ""
        
        # Get app argument
        APP_INPUT="$1"
        if [ -z "$APP_INPUT" ]; then
            # Try loading from context
            APP_INPUT=$(get_current_app)
            if [ -z "$APP_INPUT" ]; then
                log_error "No app specified and no active app context"
                log_info "Usage: tfgrid-compose up <app-name>"
                log_info "Or:    tfgrid-compose up <app-path>"
                log_info "Or:    tfgrid-compose up <app> --name=<suffix>"
                exit 1
            fi
            log_info "Using active app: $APP_INPUT"
        fi
        
        # Determine if input is app name or path
        APP_NAME=""
        APP_PATH=""
        
        if [[ "$APP_INPUT" == */* ]] || [[ "$APP_INPUT" == .* ]]; then
            # It's a path (contains / or starts with .)
            APP_PATH="$APP_INPUT"
            APP_NAME=$(basename "$APP_PATH")
            log_info "Deploying from path: $APP_PATH"
        else
            # It's an app name from registry
            APP_NAME="$APP_INPUT"
            log_info "Looking up $APP_NAME in registry..."
            
            # Get repo URL from registry
            REPO_URL=$(get_app_repo "$APP_NAME")
            if [ -z "$REPO_URL" ]; then
                log_error "App '$APP_NAME' not found in registry"
                log_info "Search apps: tfgrid-compose search"
                exit 1
            fi
            
            # Get or download app
            APP_PATH=$(get_app "$APP_NAME" "$REPO_URL")
            if [ -z "$APP_PATH" ]; then
                exit 1
            fi
            
            log_success "Using app: $APP_NAME"
        fi
        
        # Validate app path
        if ! validate_app_path "$APP_PATH"; then
            exit 1
        fi
        
        # Parse deployment flags FIRST (before checking deployment status)
        shift  # Remove app name
        PATTERN_NAME=""
        INTERACTIVE_MODE=false
        FORCE_DEPLOY=false
        REFRESH_CACHE=false
        NO_REFRESH=false
        CUSTOM_NODE=""
        CUSTOM_CPU=""
        CUSTOM_MEM=""
        CUSTOM_DISK=""
        CUSTOM_NETWORK=""
        CUSTOM_BLACKLIST_NODES=""
        CUSTOM_BLACKLIST_FARMS=""
        CUSTOM_WHITELIST_FARMS=""
        CUSTOM_MAX_CPU_USAGE=""
        CUSTOM_MAX_DISK_USAGE=""
        CUSTOM_MIN_UPTIME_DAYS=""
        
        while [[ $# -gt 0 ]]; do
            case $1 in
                --pattern)
                    PATTERN_NAME="$2"
                    shift 2
                    ;;
                --pattern=*)
                    PATTERN_NAME="${1#--pattern=}"
                    shift
                    ;;
                -i|--interactive)
                    INTERACTIVE_MODE=true
                    shift
                    ;;
                --force|-f)
                    FORCE_DEPLOY=true
                    shift
                    ;;
                --refresh)
                    REFRESH_CACHE=true
                    shift
                    ;;
                --no-refresh)
                    NO_REFRESH=true
                    shift
                    ;;
                --node)
                            CUSTOM_NODE="$2"
                            shift 2
                            ;;
                        --node=*)
                            CUSTOM_NODE="${1#--node=}"
                            shift
                            ;;
                        --name)
                            DEPLOYMENT_NAME="$2"
                            shift 2
                            ;;
                        --name=*)
                            DEPLOYMENT_NAME="${1#--name=}"
                            shift
                            ;;
                        --cpu)
                            CUSTOM_CPU="$2"
                            shift 2
                            ;;
                        --mem|--memory)
                            CUSTOM_MEM="$2"
                            shift 2
                            ;;
                        --disk)
                            CUSTOM_DISK="$2"
                            shift 2
                            ;;
                        --network)
                            CUSTOM_NETWORK="$2"
                            shift 2
                            ;;
                        --blacklist-node)
                            CUSTOM_BLACKLIST_NODES="$2"
                            shift 2
                            ;;
                        --blacklist-node=*)
                            CUSTOM_BLACKLIST_NODES="${1#--blacklist-node=}"
                            shift
                            ;;
                        --blacklist-farm)
                            CUSTOM_BLACKLIST_FARMS="$2"
                            shift 2
                            ;;
                        --blacklist-farm=*)
                            CUSTOM_BLACKLIST_FARMS="${1#--blacklist-farm=}"
                            shift
                            ;;
                        --whitelist-farm)
                            CUSTOM_WHITELIST_FARMS="$2"
                            shift 2
                            ;;
                        --whitelist-farm=*)
                            CUSTOM_WHITELIST_FARMS="${1#--whitelist-farm=}"
                            shift
                            ;;
                        --max-cpu-usage)
                            CUSTOM_MAX_CPU_USAGE="$2"
                            shift 2
                            ;;
                        --max-cpu-usage=*)
                            CUSTOM_MAX_CPU_USAGE="${1#--max-cpu-usage=}"
                            shift
                            ;;
                        --max-disk-usage)
                            CUSTOM_MAX_DISK_USAGE="$2"
                            shift 2
                            ;;
                        --max-disk-usage=*)
                            CUSTOM_MAX_DISK_USAGE="${1#--max-disk-usage=}"
                            shift
                            ;;
                        --min-uptime-days)
                            CUSTOM_MIN_UPTIME_DAYS="$2"
                            shift 2
                            ;;
                        --min-uptime-days=*)
                            CUSTOM_MIN_UPTIME_DAYS="${1#--min-uptime-days=}"
                            shift
                            ;;
                --verbose|-v)
                    export TFGRID_VERBOSE=1
                    shift
                    ;;
                *)
                    log_warning "Unknown flag: $1"
                    shift
                    ;;
            esac
        done
        
        # Export for use in orchestrator
        export INTERACTIVE_MODE
        export CUSTOM_NODE
        export CUSTOM_CPU
        export CUSTOM_MEM
        export CUSTOM_DISK
        export CUSTOM_NETWORK
        export CUSTOM_BLACKLIST_NODES
        export CUSTOM_BLACKLIST_FARMS
        export CUSTOM_WHITELIST_FARMS
        export CUSTOM_MAX_CPU_USAGE
        export CUSTOM_MAX_DISK_USAGE
        export CUSTOM_MIN_UPTIME_DAYS
        
        # Handle cache refresh logic
        # --force implies --refresh unless --no-refresh is specified
        if [ "$FORCE_DEPLOY" = "true" ] && [ "$NO_REFRESH" != "true" ]; then
            REFRESH_CACHE=true
        fi
        
        # Track if we destroyed a deployment (for cache refresh)
        DESTROYED_DEPLOYMENT=false
        
        # Check if app is already deployed or has stale state
        if is_app_deployed "$APP_NAME"; then
            # Check if deployment is healthy
            if is_deployment_healthy "$APP_NAME"; then
                if [ "$FORCE_DEPLOY" = "true" ]; then
                    log_warning "Force deploy requested, destroying existing deployment..."
                    export_app_state_dir "$APP_NAME"
                    # Load app for destroy operation (before clearing cache)
                    if ! load_app "$APP_PATH"; then
                        exit 1
                    fi
                    if ! destroy_deployment; then
                        log_error "Failed to destroy existing deployment"
                        exit 1
                    fi
                    DESTROYED_DEPLOYMENT=true
                    echo ""
                else
                    # Auto-generate unique deployment name instead of erroring
                    UNIQUE_APP_NAME=$(generate_unique_deployment_name "$APP_NAME" "$DEPLOYMENT_NAME")
                    
                    if [ "$UNIQUE_APP_NAME" != "$APP_NAME" ]; then
                        log_info "Using deployment name: $UNIQUE_APP_NAME"
                        log_info "First deployment: $APP_NAME"
                        log_info "This deployment: $UNIQUE_APP_NAME"
                    fi
                    
                    # Update APP_NAME for rest of deployment
                    APP_NAME="$UNIQUE_APP_NAME"
                    export APP_NAME
                fi
            else
                # Deployment exists but unhealthy - clean stale state
                log_warning "Found unhealthy deployment state for $APP_NAME"
                
                # Check if force deploy is requested
                if [ "$FORCE_DEPLOY" = "true" ]; then
                    log_info "Force deploy requested, cleaning unhealthy state..."
                    clean_stale_state "$APP_NAME"
                    DESTROYED_DEPLOYMENT=true
                    echo ""
                elif ! validate_terraform_state "$APP_NAME"; then
                    log_info "Detected stale Terraform state, cleaning..."
                    clean_stale_state "$APP_NAME"
                    echo ""
                else
                    log_error "Deployment exists but is unhealthy"
                    log_info "Use --force to clean and redeploy: tfgrid-compose up $APP_NAME --force"
                    exit 1
                fi
            fi
        fi
        
        # Refresh app cache if requested and we destroyed something
        # Pull latest code from repository
        if [ "$REFRESH_CACHE" = "true" ] && [ "$DESTROYED_DEPLOYMENT" = "true" ]; then
            log_info "Refreshing app cache..."
            
            if [ "$FORCE_DEPLOY" = "true" ]; then
                # For --force, delete and re-clone to guarantee fresh code
                log_info "Force deploy: removing cached app for fresh download..."
                clean_app_cache "$APP_NAME"
                
                # Re-download fresh from registry
                log_info "Downloading fresh app from registry..."
                APP_PATH=$(get_app "$APP_NAME" "$REPO_URL")
                if [ -z "$APP_PATH" ]; then
                    log_error "Failed to download app after cache cleanup"
                    exit 1
                fi
            else
                # For regular refresh, try git pull
                update_cached_app "$APP_NAME" || true  # Don't fail if update fails, use existing cache
            fi
            echo ""
        elif [ "$REFRESH_CACHE" = "true" ] && [ "$FORCE_DEPLOY" != "true" ]; then
            # Explicit --refresh without --force: update cached app
            log_info "Refreshing app cache..."
            update_cached_app "$APP_NAME" || true  # Don't fail if update fails, use existing cache
            echo ""
        fi
        
        # Initialize deployment state for this app
        init_deployment_state "$APP_NAME"
        export_app_state_dir "$APP_NAME"
        
        # Load app
        if ! load_app "$APP_PATH"; then
            exit 1
        fi
        
        # Determine pattern to use
        if [ -z "$PATTERN_NAME" ]; then
            PATTERN_NAME=$(get_recommended_pattern)
            if [ -z "$PATTERN_NAME" ]; then
                log_error "No pattern specified and no recommended pattern in manifest"
                log_info "Usage: tfgrid-compose up <app> --pattern=<pattern>"
                exit 1
            fi
            log_info "Using recommended pattern: $PATTERN_NAME"
        fi
        
        # Load pattern
        if ! load_pattern "$PATTERN_NAME"; then
            exit 1
        fi
        
        # Check compatibility
        if ! check_pattern_compatibility "$PATTERN_NAME"; then
            exit 1
        fi
        
        # Validate app structure
        if ! validate_app_structure; then
            exit 1
        fi
        
        # Validate pattern requirements
        if ! validate_pattern_requirements; then
            exit 1
        fi
        
        echo ""
        
        # Load preferences for deployment (before validation)
        export_for_deployment
        
        # Validate network prerequisites based on manifest config
        main_network=$(yaml_get "$APP_MANIFEST" "network.main")
        inter_node=$(yaml_get "$APP_MANIFEST" "network.inter_node")
        mode=$(yaml_get "$APP_MANIFEST" "network.mode")
        
        if ! validate_network_prerequisites "$main_network" "$inter_node" "$mode"; then
            log_error "Network validation failed"
            exit 1
        fi
        
        echo ""
        log_success "All validations passed! Starting deployment..."
        echo ""
        
        # Deploy the app
        if ! deploy_app; then
            log_error "Deployment failed"
            exit 1
        fi
        
        exit 0
        ;;
    
    ps)
        # Docker-style deployment list
        log_info "TFGrid Compose v$VERSION - Docker-style Deployment List"
        echo ""
        
        list_deployments_docker_style
        exit $?
        ;;
        
    inspect)
        # Docker-style deployment inspection
        DEPLOYMENT_ID="${1:-}"
        
        if [ -z "$DEPLOYMENT_ID" ]; then
            echo ""
            echo "Usage: tfgrid-compose inspect <deployment-id>"
            echo ""
            echo "Example: tfgrid-compose inspect abc123def456"
            echo ""
            echo "Get deployment ID from: tfgrid-compose ps"
            exit 1
        fi
        
        log_info "TFGrid Compose v$VERSION - Deployment Inspection"
        echo ""
        
        # Resolve deployment ID or app name to actual ID with enhanced resolution
        RESOLVED_DEPLOYMENT=$(resolve_deployment "$DEPLOYMENT_ID" 2>/dev/null)
        RESOLVE_RESULT=$?
        
        case $RESOLVE_RESULT in
            0)
                # Single match found
                RESOLVED_ID="$RESOLVED_DEPLOYMENT"
                ;;
            3)
                # Multiple matches - show selection menu
                echo ""
                echo "üì± Multiple deployments found for: $DEPLOYMENT_ID"
                echo ""
                
                # Parse ambiguous results and show options
                local IFS=$'\n'
                local options=($RESOLVED_DEPLOYMENT)
                local deployment_info=()
                
                for i in "${!options[@]}"; do
                    local deployment_id="${options[$i]}"
                    local details=$(get_deployment_by_id "$deployment_id" 2>/dev/null)
                    
                    if [ -n "$details" ]; then
                        local app_name=$(echo "$details" | grep "app_name:" | awk '{print $2}')
                        local vm_ip=$(echo "$details" | grep "vm_ip:" | awk '{print $2}')
                        local created_at=$(echo "$details" | grep "created_at:" | awk '{print $2}')
                        local age=$(calculate_deployment_age "$created_at" 2>/dev/null || echo "unknown")
                        
                        echo "$((i+1))) $deployment_id $app_name ($vm_ip) - $age"
                        deployment_info+=("$deployment_id")
                    fi
                done
                
                echo ""
                read -p "Select deployment [1-${#options[@]}]: " choice
                
                # Validate choice
                if ! [[ "$choice" =~ ^[0-9]+$ ]] || [ "$choice" -lt 1 ] || [ "$choice" -gt ${#options[@]} ]; then
                    log_error "Invalid choice"
                    exit 1
                fi
                
                # Get selected deployment
                RESOLVED_ID="${deployment_info[$((choice-1))]}"
                echo ""
                log_info "Inspecting deployment: $RESOLVED_ID"
                ;;
            *)
                # No matches found
                log_error "Deployment not found: $DEPLOYMENT_ID"
                log_info "Use 'tfgrid-compose ps' to see available deployments"
                exit 1
                ;;
        esac
        
        echo "Deployment Details:"
        echo "==================="
        echo ""
        
        # Get deployment details
        DEPLOYMENT_DETAILS=$(get_deployment_by_id "$RESOLVED_ID")
        
        if [ -z "$DEPLOYMENT_DETAILS" ]; then
            log_error "Deployment details not found for ID: $RESOLVED_ID"
            exit 1
        fi
        
        # Display deployment details
        if command_exists yq; then
            echo "$DEPLOYMENT_DETAILS" | yq eval '.' -
        else
            echo "$DEPLOYMENT_DETAILS"
        fi
        
        echo ""
        echo "State Directory: $HOME/.config/tfgrid-compose/state/$RESOLVED_ID"
        echo ""
        
        # Show state.yaml if it exists
        local state_file="$HOME/.config/tfgrid-compose/state/$RESOLVED_ID/state.yaml"
        if [ -f "$state_file" ]; then
            echo "State Configuration:"
            echo "-------------------"
            if command_exists yq; then
                yq eval '.' "$state_file" 2>/dev/null || cat "$state_file"
            else
                cat "$state_file"
            fi
        fi
        
        exit 0
        ;;
        
    down)
        # Down command
        log_info "TFGrid Compose v$VERSION"
        echo ""
        
        # Try to get app path from argument or context
        APP_PATH="$1"
        if [ -z "$APP_PATH" ]; then
            APP_PATH=$(load_context)
            if [ -z "$APP_PATH" ]; then
                log_error "No app specified and no context file found"
                log_info "Usage: tfgrid-compose down <app>"
                exit 1
            fi
            log_info "Using app from context: $APP_PATH"
        fi
        
        # If it's a name (not a path), look up in registry
        if [[ ! "$APP_PATH" =~ ^\.?/ ]] && [ ! -d "$APP_PATH" ]; then
            APP_NAME="$APP_PATH"
            log_info "Looking up $APP_NAME in registry..."
            
            # Check cache first
            if is_app_cached "$APP_NAME"; then
                APP_PATH="$APPS_CACHE_DIR/$APP_NAME"
                log_success "Using app: $APP_NAME"
            else
                # Download from registry
                REPO_URL=$(get_app_repo "$APP_NAME")
                if [ $? -ne 0 ]; then
                    log_error "App not found in registry: $APP_NAME"
                    exit 1
                fi
                
                APP_PATH=$(get_app "$APP_NAME" "$REPO_URL")
                if [ $? -ne 0 ]; then
                    exit 1
                fi
                log_success "Using app: $APP_NAME"
            fi
        fi
        
        # Validate app path
        if ! validate_app_path "$APP_PATH"; then
            exit 1
        fi
        
        # Check deployment exists
        if ! validate_deployment_exists; then
            exit 1
        fi
        
        # Load mnemonic (needed for Terraform destroy)
        if ! load_mnemonic; then
            exit 1
        fi
        log_success "ThreeFold mnemonic configured"
        echo ""
        
        # Load app to get configuration (needed for Terraform variables)
        if ! load_app "$APP_PATH"; then
            exit 1
        fi
        
        # Get pattern from manifest
        PATTERN_NAME=$(get_recommended_pattern)
        if [ -z "$PATTERN_NAME" ]; then
            log_error "No pattern specified and no recommended pattern in manifest"
            exit 1
        fi
        
        # Load pattern (needed for generate_terraform_config)
        if ! load_pattern "$PATTERN_NAME"; then
            exit 1
        fi
        
        # Parse manifest and export Terraform variables (but don't copy infrastructure)
        # Just parse config to export TF_VAR_* environment variables
        log_info "Loading configuration from manifest..."
        
        # Parse nodes, resources, gateway, network config (no 'local' - not in function)
        gateway_nodes=$(yaml_get "$APP_MANIFEST" "nodes.gateway")
        backend_nodes=$(yaml_get "$APP_MANIFEST" "nodes.backend")
        vm_node=$(yaml_get "$APP_MANIFEST" "nodes.vm")
        
        if [ -n "$gateway_nodes" ]; then
            if [[ "$gateway_nodes" == "["* ]]; then
                export TF_VAR_gateway_node=$(echo "$gateway_nodes" | tr -d '[]' | awk '{print $1}' | tr -d ',')
            else
                export TF_VAR_gateway_node="$gateway_nodes"
            fi
        fi
        
        [ -n "$backend_nodes" ] && export TF_VAR_internal_nodes="$backend_nodes"
        [ -n "$vm_node" ] && export TF_VAR_vm_node="$vm_node"
        
        # Parse resources
        gateway_cpu=$(yaml_get "$APP_MANIFEST" "resources.gateway.cpu")
        gateway_mem=$(yaml_get "$APP_MANIFEST" "resources.gateway.memory")
        gateway_disk=$(yaml_get "$APP_MANIFEST" "resources.gateway.disk")
        backend_cpu=$(yaml_get "$APP_MANIFEST" "resources.backend.cpu")
        backend_mem=$(yaml_get "$APP_MANIFEST" "resources.backend.memory")
        backend_disk=$(yaml_get "$APP_MANIFEST" "resources.backend.disk")
        vm_cpu=$(yaml_get "$APP_MANIFEST" "resources.vm.cpu")
        vm_mem=$(yaml_get "$APP_MANIFEST" "resources.vm.memory")
        vm_disk=$(yaml_get "$APP_MANIFEST" "resources.vm.disk")
        
        [ -n "$gateway_cpu" ] && export TF_VAR_gateway_cpu="$gateway_cpu"
        [ -n "$gateway_mem" ] && export TF_VAR_gateway_mem="$gateway_mem"
        [ -n "$gateway_disk" ] && export TF_VAR_gateway_disk="$gateway_disk"
        [ -n "$backend_cpu" ] && export TF_VAR_internal_cpu="$backend_cpu"
        [ -n "$backend_mem" ] && export TF_VAR_internal_mem="$backend_mem"
        [ -n "$backend_disk" ] && export TF_VAR_internal_disk="$backend_disk"
        [ -n "$vm_cpu" ] && export TF_VAR_vm_cpu="$vm_cpu"
        [ -n "$vm_mem" ] && export TF_VAR_vm_mem="$vm_mem"
        [ -n "$vm_disk" ] && export TF_VAR_vm_disk="$vm_disk"
        
        # Parse network
        main_network=$(yaml_get "$APP_MANIFEST" "network.main")
        export MAIN_NETWORK="${main_network:-wireguard}"
        export TF_VAR_main_network="$MAIN_NETWORK"
        export TF_VAR_tfgrid_network="${TF_VAR_tfgrid_network:-main}"
        
        log_success "Configuration loaded from manifest"
        
        # Destroy the deployment
        if ! destroy_deployment; then
            log_error "Destroy failed"
            exit 1
        fi
        
        # Cleanup deployment status tracking
        cleanup_deployment "$APP_NAME"
        
        # Auto-unselect if this was the active app
        CURRENT_APP_FILE="$HOME/.config/tfgrid-compose/current-app"
        if [ -f "$CURRENT_APP_FILE" ]; then
            CURRENT_APP=$(cat "$CURRENT_APP_FILE")
            if [ "$CURRENT_APP" = "$APP_NAME" ]; then
                rm "$CURRENT_APP_FILE"
                echo ""
                log_info "Unselected (app no longer deployed)"
            fi
        fi
        
        exit 0
        ;;
        
    clean)
        # Clean up state directory
        log_info "TFGrid Compose v$VERSION"
        echo ""
        
        if [ -d "$STATE_DIR" ]; then
            log_warning "This will remove the local state directory: $STATE_DIR"
            read -p "Are you sure? (y/N): " -n 1 -r
            echo
            if [[ $REPLY =~ ^[Yy]$ ]]; then
                rm -rf "$STATE_DIR"
                log_success "State directory cleaned"
            else
                log_info "Cancelled"
            fi
        else
            log_info "No state directory found (already clean)"
        fi
        exit 0
        ;;
        
    logs)
        # Logs command - context-based precedence
        # If app is selected and has 'logs' command, use app version
        if app_has_command "logs"; then
            execute_app_command "logs" "$@"
            exit $?
        fi
        
        # Use built-in logs (pattern-based)
        # Try to get app from argument or context
        APP_INPUT="$1"
        if [ -z "$APP_INPUT" ]; then
            APP_INPUT=$(load_context)
            if [ -z "$APP_INPUT" ]; then
                log_error "No app specified and no app selected"
                log_info "Usage: tfgrid-compose logs <app>"
                log_info "   Or: tfgrid-compose select <app> && tfgrid-compose logs"
                exit 1
            fi
        fi
        
        # Resolve app path (handles both deployment IDs and app names)
        APP_PATH=$(resolve_app_path "$APP_INPUT")
        if [ -z "$APP_PATH" ]; then
            log_error "Failed to resolve app: $APP_INPUT"
            exit 1
        fi
        
        # Set app name for validation
        APP_NAME=$(basename "$APP_PATH")
        export APP_NAME
        
        # Validate app path
        if ! validate_app_path "$APP_PATH"; then
            exit 1
        fi
        
        # Check deployment exists
        if ! validate_deployment_exists; then
            exit 1
        fi
        
        # Load app to get pattern
        if ! load_app "$APP_PATH"; then
            exit 1
        fi
        
        # Get pattern from state (for now, use recommended)
        PATTERN_NAME=$(get_recommended_pattern)
        
        if [ -z "$PATTERN_NAME" ]; then
            log_error "Cannot determine pattern for app"
            exit 1
        fi
        
        # Load pattern
        if ! load_pattern "$PATTERN_NAME"; then
            exit 1
        fi
        
        # Execute pattern logs script
        execute_pattern_script "logs"
        ;;
        
    status)
        # Status command
        # Try to get app from argument or context
        APP_INPUT="$1"
        if [ -z "$APP_INPUT" ]; then
            APP_INPUT=$(load_context)
            if [ -z "$APP_INPUT" ]; then
                log_error "No app specified and no context file found"
                log_info "Usage: tfgrid-compose status <app>"
                exit 1
            fi
        fi
        
        # Resolve app path (registry name or local path)
        APP_PATH=$(resolve_app_path "$APP_INPUT")
        if [ -z "$APP_PATH" ]; then
            log_error "Failed to resolve app: $APP_INPUT"
            exit 1
        fi
        
        # Set app name for validation
        APP_NAME=$(basename "$APP_PATH")
        export APP_NAME
        
        # Validate app path
        if ! validate_app_path "$APP_PATH"; then
            exit 1
        fi
        
        # Check deployment exists
        if ! validate_deployment_exists; then
            exit 1
        fi
        
        # Load app
        if ! load_app "$APP_PATH"; then
            exit 1
        fi
        
        # Get pattern
        PATTERN_NAME=$(get_recommended_pattern)
        
        if [ -z "$PATTERN_NAME" ]; then
            log_error "Cannot determine pattern for app"
            exit 1
        fi
        
        # Load pattern
        if ! load_pattern "$PATTERN_NAME"; then
            exit 1
        fi
        
        # Execute pattern status script
        execute_pattern_script "status"
        ;;
        
    ssh|connect)
        # SSH command
        # Try to get app from argument or context
        APP_INPUT="$1"
        if [ -z "$APP_INPUT" ]; then
            APP_INPUT=$(load_context)
            if [ -z "$APP_INPUT" ]; then
                log_error "No app specified and no context file found"
                log_info "Usage: tfgrid-compose ssh <app>"
                exit 1
            fi
        fi
        
        # Resolve app path (registry name or local path)
        APP_PATH=$(resolve_app_path "$APP_INPUT")
        if [ -z "$APP_PATH" ]; then
            log_error "Failed to resolve app: $APP_INPUT"
            exit 1
        fi
        
        # Set and export app name
        APP_NAME=$(basename "$APP_PATH")
        export APP_NAME
        
        # Load app
        if ! load_app "$APP_PATH"; then
            exit 1
        fi
        
        # Get pattern
        PATTERN_NAME=$(get_recommended_pattern)
        
        if [ -z "$PATTERN_NAME" ]; then
            log_error "Cannot determine pattern for app"
            exit 1
        fi
        
        # Load pattern
        if ! load_pattern "$PATTERN_NAME"; then
            exit 1
        fi
        
        # Execute pattern connect script
        execute_pattern_script "connect"
        ;;
        
address)
    # Address command - show deployment addresses
    log_command "Deployment Addresses"

    # Enhanced detection: Support deployment names, smart context, and interactive selection
    APP_INPUT="$1"
    DEPLOYMENT_ID=""

    if [ -n "$APP_INPUT" ]; then
        # Direct deployment/app name provided
        RESOLVED_DEPLOYMENT=$(resolve_deployment "$APP_INPUT")
        RESOLVE_RESULT=$?

        case $RESOLVE_RESULT in
            0)
                # Single match found
                DEPLOYMENT_ID="$RESOLVED_DEPLOYMENT"
                ;;
            3)
                # Multiple matches - show selection menu
                echo ""
                log_error "Multiple deployments match: $APP_INPUT"
                echo ""
                echo "Available deployments:"
                IFS=$'\n'
                options=($RESOLVED_DEPLOYMENT)
                for i in "${!options[@]}"; do
                    deployment_id="${options[$i]}"
                    details=$(get_deployment_by_id "$deployment_id" 2>/dev/null)
                    if [ -n "$details" ]; then
                        app_name=$(echo "$details" | grep "app_name:" | awk '{print $2}' | tr -d '"' || echo "")
                        vm_ip=$(echo "$details" | grep "vm_ip:" | awk '{print $2}' | tr -d '"' || echo "")
                        mycelium_ip=$(echo "$details" | grep "mycelium_ip:" | awk '{print $2}' | tr -d '"' || echo "")
                        echo "  $deployment_id $app_name ($vm_ip) $([ -n "$mycelium_ip" ] && echo "[mycelium: $mycelium_ip]")"
                    fi
                done
                echo ""
                read -p "Enter deployment ID: " chosen_id
                if [ -n "$chosen_id" ] && [[ " ${options[@]} " =~ " $chosen_id " ]]; then
                    DEPLOYMENT_ID="$chosen_id"
                else
                    log_error "Invalid selection"
                    exit 1
                fi
                ;;
            *)
                # No matches found
                log_error "Deployment not found: $APP_INPUT"
                log_info "Use 'tfgrid-compose ps' to see available deployments"
                exit 1
                ;;
        esac
    else
        # No argument - use smart context detection
        CONTEXT_APP=$(get_smart_context)

        if [ -z "$CONTEXT_APP" ]; then
            # No context, show interactive selection
            all_deployments=$(get_all_deployments 2>/dev/null || echo "")

            if [ -z "$all_deployments" ]; then
                log_error "No deployments found"
                log_info "Deploy an app first: tfgrid-compose up <app-name>"
                exit 1
            fi

            echo ""
            echo "üì± Select deployment to show addresses:"
            echo ""

            deployment_options=()
            deployment_ids=()

            if command_exists yq; then
                while IFS='|' read -r deployment_id app_name vm_ip contract_id status created_at; do
                    if [ -n "$deployment_id" ] && [ -n "$app_name" ] && [ "$status" = "active" ]; then
                        mycelium_ip=$(yq eval ".deployments.\"$deployment_id\".mycelium_ip // \"\"" "$HOME/.config/tfgrid-compose/deployments.yaml" 2>/dev/null || echo "")
                        display_name="$deployment_id $app_name ($vm_ip)"
                        [ -n "$mycelium_ip" ] && display_name="$display_name [mycelium: $mycelium_ip]"
                        deployment_options+=("$display_name")
                        deployment_ids+=("$deployment_id")
                    fi
                done <<< "$all_deployments"
            fi

            if [ ${#deployment_options[@]} -eq 0 ]; then
                log_error "No active deployments found"
                exit 1
            fi

            for i in "${!deployment_options[@]}"; do
                echo "$((i+1))) ${deployment_options[$i]}"
            done

            echo ""
            read -p "Enter number [1-${#deployment_options[@]}] or 'q' to quit: " choice

            if [ "$choice" = "q" ] || [ "$choice" = "Q" ]; then
                echo ""
                log_info "Cancelled"
                exit 0
            fi

            if ! [[ "$choice" =~ ^[0-9]+$ ]] || [ "$choice" -lt 1 ] || [ "$choice" -gt ${#deployment_options[@]} ]; then
                log_error "Invalid choice"
                exit 1
            fi

            DEPLOYMENT_ID="${deployment_ids[$((choice-1))]}"
        else
            # Use detected context
            DEPLOYMENT_ID="$CONTEXT_APP"
        fi
    fi

    # Now we have DEPLOYMENT_ID - show addresses
    echo ""
    echo "üåê Deployment Addresses: $DEPLOYMENT_ID"
    echo ""

    # Get deployment details
    details=$(get_deployment_by_id "$DEPLOYMENT_ID")
    if [ -z "$details" ]; then
        log_error "Could not get deployment details for: $DEPLOYMENT_ID"
        exit 1
    fi

    app_name=$(echo "$details" | grep "^app_name:" | awk '{print $2}' | tr -d '"')
    vm_ip=$(echo "$details" | grep "^vm_ip:" | awk '{print $2}' | tr -d '"')
    mycelium_ip=$(echo "$details" | grep "^mycelium_ip:" | awk '{print $2}' | tr -d '"' || echo "")
    contract_id=$(echo "$details" | grep "^contract_id:" | awk '{print $2}' | tr -d '"')
    created_at=$(echo "$details" | grep "^created_at:" | awk '{print $2}' | tr -d '"')
    state_dir=$(echo "$details" | grep "^state_dir:" | awk '{print $2}' | tr -d '"')

    # Fallback: handle vm_ip/mycelium_ip stored as YAML block scalars (vm_ip: |-) by reading from state.yaml
    if [ "$vm_ip" = "|-" ] || [ -z "$vm_ip" ]; then
        if [ -n "$state_dir" ] && [ -f "$state_dir/state.yaml" ]; then
            vm_ip=$(grep "^vm_ip:" "$state_dir/state.yaml" 2>/dev/null | head -n1 | awk '{print $2}')
        fi
    fi
    if [ "$mycelium_ip" = "|-" ] || [ -z "$mycelium_ip" ]; then
        if [ -n "$state_dir" ] && [ -f "$state_dir/state.yaml" ]; then
            mycelium_ip=$(grep "^mycelium_ip:" "$state_dir/state.yaml" 2>/dev/null | head -n1 | awk '{print $2}')
        fi
    fi

    echo "üìã Deployment: $DEPLOYMENT_ID"
    echo "üè∑Ô∏è  App: $app_name"
    if [ -n "$contract_id" ] && [ "$contract_id" != "null" ]; then
        echo "üîó Contract: $contract_id"
    fi
    if [ -n "$created_at" ]; then
        age=$(calculate_deployment_age "$created_at")
        echo "üìÖ Created: $age"
    fi
    echo ""

    # Show addresses based on app type
    case "${app_name:-unknown}" in
        tfgrid-ai-stack)
            echo "üåê Access URLs:"
            echo ""
            if [ -n "$vm_ip" ]; then
                echo "üì¶ WireGuard Addresses (IPv4):"
                echo "  ‚Ä¢ Gateway:       http://$vm_ip/"
                echo "  ‚Ä¢ Gitea (Git):   http://$vm_ip/git/"
                echo "  ‚Ä¢ AI Agent API:  http://$vm_ip/api/"
                echo ""
            fi

            if [ -n "$mycelium_ip" ]; then
                echo "ü´ö Mycelium Addresses (IPv6):"
                echo "  ‚Ä¢ Gateway:       http://[$mycelium_ip]/"
                echo "  ‚Ä¢ Gitea (Git):   http://[$mycelium_ip]/git/"
                echo "  ‚Ä¢ AI Agent API:  http://[$mycelium_ip]/api/"
                echo ""
                echo "üí° Pro tip: Mycelium URLs work from anywhere on the internet!"
            fi

            if [ -z "$mycelium_ip" ] && [ -z "$vm_ip" ]; then
                echo "‚ùå No IP addresses found for this deployment"
            fi

            echo ""
            echo "üîß Management:"
            echo "  ‚Ä¢ SSH:           tfgrid-compose ssh $DEPLOYMENT_ID"
            echo "  ‚Ä¢ Status:        tfgrid-compose status $app_name"
            echo "  ‚Ä¢ Logs:          tfgrid-compose exec $DEPLOYMENT_ID logs"
            ;;

        tfgrid-ai-agent)
            echo "ü§ñ AI Agent URLs:"
            echo ""
            if [ -n "$vm_ip" ]; then
                echo "  ‚Ä¢ API:           http://$vm_ip:8000"
                echo "  ‚Ä¢ Health:        http://$vm_ip:8000/health"
                echo ""
            fi
            echo "üîß Management:"
            echo "  ‚Ä¢ SSH:           tfgrid-compose ssh $DEPLOYMENT_ID"
            echo "  ‚Ä¢ Logs:          tfgrid-compose logs $app_name"
            ;;

        tfgrid-gitea)
            echo "üì¶ Gitea Git Server:"
            echo ""
            if [ -n "$vm_ip" ]; then
                echo "  ‚Ä¢ Web Interface: http://$vm_ip:3000"
                echo ""
            fi
            if [ -n "$mycelium_ip" ]; then
                echo "  ‚Ä¢ Mycelium Web:  http://[$mycelium_ip]:3000"
                echo ""
            fi
            echo "üîß Management:"
            echo "  ‚Ä¢ SSH:           tfgrid-compose ssh $DEPLOYMENT_ID"
            ;;

        *)
            # Generic display for other apps
            echo "üåê Network Addresses:"
            echo ""
            if [ -n "$vm_ip" ]; then
                echo "üì° WireGuard (VPN):   $vm_ip"
                echo ""
            fi
            if [ -n "$mycelium_ip" ]; then
                echo "ü´ö Mycelium (Global):  $mycelium_ip"
                echo ""
                echo "üí° Mycelium provides global IPv6 connectivity!"
                echo ""
            fi
            echo "üîß Management:"
            echo "  ‚Ä¢ SSH:             tfgrid-compose ssh $DEPLOYMENT_ID"
            echo "  ‚Ä¢ Status:          tfgrid-compose status $app_name"
            ;;
    esac

    echo ""
    log_info "üîç Not seeing the expected URLs?"
    echo "   Run: tfgrid-compose ps"
    exit 0
    ;;
        
    init)
        # Initialize app configuration
        if [ -z "$1" ]; then
            log_error "Usage: tfgrid-compose init <app>"
            exit 1
        fi
        
        APP_PATH="$1"
        
        log_info "TFGrid Compose v$VERSION - Initialize Configuration"
        echo ""
        
        # Load app
        if ! load_app "$APP_PATH"; then
            exit 1
        fi
        
        # Check if .env already exists
        if [ -f "$APP_DIR/.env" ]; then
            read -p "‚ö†Ô∏è  .env already exists. Overwrite? (y/N): " -n 1 -r
            echo
            if [[ ! $REPLY =~ ^[Yy]$ ]]; then
                log_info "Aborted."
                exit 0
            fi
        fi
        
        echo "üì° ThreeFold Grid Configuration"
        echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
        read -p "Node ID for VM: " NODE_ID
        if [ -z "$NODE_ID" ]; then
            log_error "Node ID is required"
            exit 1
        fi
        
        read -p "TFGrid Network (main/test/dev) [main]: " NETWORK
        NETWORK=${NETWORK:-main}
        
        echo ""
        echo "üîß VM Resources"
        echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
        
        # Get recommended resources from app
        REC_CPU=$(get_app_resource "cpu" "recommended")
        REC_MEM=$(get_app_resource "memory" "recommended")
        REC_DISK=$(get_app_resource "disk" "recommended")
        
        read -p "CPU cores [${REC_CPU:-4}]: " CPU
        CPU=${CPU:-${REC_CPU:-4}}
        read -p "Memory (MB) [${REC_MEM:-8192}]: " MEM
        MEM=${MEM:-${REC_MEM:-8192}}
        read -p "Disk (GB) [${REC_DISK:-100}]: " DISK
        DISK=${DISK:-${REC_DISK:-100}}
        
        echo ""
        echo "üåê Network Connectivity"
        echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
        read -p "Connectivity (wireguard/mycelium) [wireguard]: " CONN
        CONN=${CONN:-wireguard}
        
        # Git config from local
        GIT_NAME=$(git config --global user.name 2>/dev/null || echo "")
        GIT_EMAIL=$(git config --global user.email 2>/dev/null || echo "")
        
        echo ""
        echo "üîê Git Configuration"
        echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
        if [ -n "$GIT_NAME" ]; then
            echo "‚úÖ Found local git config:"
            echo "   Name:  $GIT_NAME"
            echo "   Email: $GIT_EMAIL"
            read -p "Use this config? (Y/n): " -n 1 -r
            echo
            if [[ $REPLY =~ ^[Nn]$ ]]; then
                read -p "Enter git name: " GIT_NAME
                read -p "Enter git email: " GIT_EMAIL
            fi
        else
            read -p "Git name: " GIT_NAME
            read -p "Git email: " GIT_EMAIL
        fi
        
        read -p "GitHub username (optional) [$GIT_NAME]: " GITHUB_USER
        GITHUB_USER=${GITHUB_USER:-$GIT_NAME}
        
        # Create .env
        cat > "$APP_DIR/.env" <<EOF
# TFGrid Compose Configuration for $APP_NAME
# Generated on $(date)

# ThreeFold Grid
export TF_VAR_tfgrid_network="$NETWORK"
export TF_VAR_ai_agent_node=$NODE_ID
export TF_VAR_ai_agent_cpu=$CPU
export TF_VAR_ai_agent_mem=$MEM
export TF_VAR_ai_agent_disk=$DISK

# Network
export CONNECTIVITY_NETWORK="$CONN"

# Git
export GIT_USER_NAME="$GIT_NAME"
export GIT_USER_EMAIL="$GIT_EMAIL"
EOF
        
        if [ -n "$GITHUB_USER" ]; then
            echo "export GITHUB_USER=\"$GITHUB_USER\"" >> "$APP_DIR/.env"
        fi
        
        echo ""
        log_success "Configuration saved to $APP_DIR/.env"
        echo ""
        log_info "Next steps:"
        echo "  1. Set your secrets (NEVER commit these!):"
        echo "     Fish: set -x TF_VAR_mnemonic (cat ~/.config/threefold/mnemonic)"
        echo "     Bash: export TF_VAR_mnemonic=\$(cat ~/.config/threefold/mnemonic)"
        echo ""
        echo "  2. Deploy your app:"
        echo "     tfgrid-compose up $APP_NAME"
        ;;
        
    exec)
        # Execute command on deployed VM
        # Usage: tfgrid-compose exec [app] <command> [args...]
        # If app is not specified, uses context from switch
        
        if [ -z "$1" ]; then
            log_error "No command specified"
            log_info "Usage: tfgrid-compose exec [app] <command> [args...]"
            log_info "Examples:"
            log_info "  tfgrid-compose exec ls /opt"
            log_info "  tfgrid-compose exec tfgrid-ai-agent ls /opt"
            exit 1
        fi
        
        # Simplified detection: Check if first arg is a deployed app
        FIRST_ARG="$1"
        APP_INPUT=""
        USE_CONTEXT=false
        
        # Check if first arg looks like an app (path or has context)
        if [[ "$FIRST_ARG" == */* ]] || [[ "$FIRST_ARG" == .* ]]; then
            # It's a path
            APP_INPUT="$1"
            shift
        else
            # Check if it's a deployed app name
            if [ -d "$STATE_BASE_DIR/$FIRST_ARG" ]; then
                # It's a deployed app
                APP_INPUT="$1"
                shift
            else
                # Not a deployed app, use context
                APP_INPUT=$(load_context)
                USE_CONTEXT=true
                if [ -z "$APP_INPUT" ]; then
                    log_error "No app specified and no context found"
                    log_info "Run 'tfgrid-compose switch <app>' first or specify app:"
                    log_info "  tfgrid-compose exec <app> <command>"
                    exit 1
                fi
                # Don't shift, $1 is the command
            fi
        fi
        
        # Check we have a command after figuring out the app
        if [ $# -eq 0 ]; then
            log_error "No command specified"
            log_info "Usage: tfgrid-compose exec [app] <command> [args...]"
            exit 1
        fi
        
        # Resolve app path
        APP_PATH=$(resolve_app_path "$APP_INPUT")
        if [ -z "$APP_PATH" ]; then
            log_error "Failed to resolve app: $APP_INPUT"
            exit 1
        fi
        
        APP_NAME=$(basename "$APP_PATH")
        export APP_NAME
        
        # Get VM IP from state
        base_dir="${STATE_BASE_DIR:-$HOME/.config/tfgrid-compose/state}"
        
        # Resolve app name to deployment ID via registry
        DEPLOYMENT_ID=$(resolve_deployment "$APP_NAME")
        if [ -z "$DEPLOYMENT_ID" ]; then
            log_error "No deployment found for: $APP_NAME"
            log_info "Deploy first with: tfgrid-compose up $APP_NAME"
            exit 1
        fi
        
        state_dir="$base_dir/$DEPLOYMENT_ID"

        if [ ! -d "$state_dir" ]; then
            log_error "Deployment state not found (inconsistent state)"
            log_info "Try redeploying: tfgrid-compose up $APP_NAME --force"
            exit 1
        fi

        # Use network-aware IP resolution
        vm_ip=$(get_deployment_ip "$DEPLOYMENT_ID")

        if [ -z "$vm_ip" ]; then
            log_error "No IP found in state for $APP_NAME"
            exit 1
        fi
        
        # Get the command and arguments
        REMOTE_CMD="$@"
        
        if [ "$USE_CONTEXT" = "true" ]; then
            log_info "Using context: $APP_NAME"
        fi
        log_info "Executing on $APP_NAME ($vm_ip): $REMOTE_CMD"
        echo ""
        
        # Execute command on VM
        ssh -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null -o LogLevel=ERROR \
            root@$vm_ip "$REMOTE_CMD"
        
        exit $?
        ;;
        
    patterns)
        # List available patterns
        log_info "TFGrid Compose v$VERSION"
        echo ""
        list_patterns
        ;;
        
    update)
        # Enhanced update command with hybrid strategy
        UPDATE_SUBCOMMAND="${1:-}"
        shift || true
        
        case "$UPDATE_SUBCOMMAND" in
            registry)
                # Parse --force flag
                FORCE_UPDATE=false
                while [[ $# -gt 0 ]]; do
                    case "$1" in
                        --force|-f)
                            FORCE_UPDATE=true
                            shift
                            ;;
                        *)
                            break
                            ;;
                    esac
                done

                # Update registry data with commit comparison
                if [ "$FORCE_UPDATE" = true ]; then
                    log_info "TFGrid Compose $VERSION - Update Registry + Apps (Forced)"
                else
                    log_info "TFGrid Compose $VERSION - Update Registry + Apps"
                fi
                echo ""

                log_info "üîÑ Updating registry data and checking all app commits..."
                echo ""

                # First update registry data (force if requested)
                if update_registry "$FORCE_UPDATE"; then
                    log_success "‚úÖ Registry data updated successfully!"
                else
                    log_error "‚ùå Failed to update registry data"
                    exit 1
                fi
                
                echo ""
                echo "üìä Checking app cache status..."
                
                # Check for outdated apps and show commit comparisons
                outdated_apps_found=false
                updated_count=0
                skipped_count=0
                
                # Get current tfgrid-compose version for reference
                CURRENT_VERSION_INFO=$(get_tfgrid_compose_version)
                CURRENT_COMMIT=$(echo "$CURRENT_VERSION_INFO" | jq -r '.git_commit // "unknown"')
                
                echo ""
                echo "üîç App Cache Status:"
                echo "  TFGrid Compose: $CURRENT_COMMIT"
                echo ""
                
                # Check each cached app for updates
                for app_dir in "$APPS_CACHE_DIR"/*; do
                    if [ -d "$app_dir/.git" ] && [ -f "$app_dir/tfgrid-compose.yaml" ]; then
                        app_name=$(basename "$app_dir")
                        
                        # Get current cached commit
                        cd "$app_dir"
                        cached_commit=$(git rev-parse --short=7 HEAD 2>/dev/null || echo "unknown")
                        cd - >/dev/null
                        
                        # Check if update is needed
                        if cache_needs_update "$app_name"; then
                            outdated_apps_found=true
                            
                            # Get latest commit from remote
                            cd "$app_dir"
                            latest_commit=$(git fetch --quiet origin main 2>/dev/null && git rev-parse --short=7 origin/main 2>/dev/null || echo "unknown")
                            cd - >/dev/null
                            
                            if [ "$latest_commit" != "unknown" ] && [ "$cached_commit" != "$latest_commit" ]; then
                                echo "üîÑ $app_name:"
                                echo "    Cached: $cached_commit"
                                echo "    Latest: $latest_commit"
                                
                                # Update the app
                                if update_cached_app "$app_name"; then
                                    ((updated_count++))
                                    echo "    ‚úÖ Updated successfully"
                                else
                                    echo "    ‚ö†Ô∏è  Update failed, using cached version"
                                fi
                            else
                                ((skipped_count++))
                                echo "‚è≠Ô∏è  $app_name: No updates available ($cached_commit)"
                            fi
                        else
                            echo "‚úÖ $app_name: Up to date ($cached_commit)"
                        fi
                    fi
                done
                
                echo ""
                if [ "$outdated_apps_found" = "true" ]; then
                    echo "üìà Update Summary:"
                    echo "  Apps updated: $updated_count"
                    echo "  Apps skipped: $skipped_count"
                    echo "  Total cached apps checked"
                    echo ""
                    log_success "‚úÖ Registry + app cache update complete!"
                    echo ""
                    echo "üß™ Test with: tfgrid-compose cache list"
                    echo "üì± Browse updated apps: tfgrid-compose search"
                else
                    log_success "‚úÖ All apps are already up to date!"
                    echo ""
                    echo "üß™ Check cache status: tfgrid-compose cache status"
                fi
                ;;
                
            ""|"")
                # Default update - update tfgrid-compose binary only
                log_info "TFGrid Compose $VERSION - Update"
                echo ""

                # Check if curl is available
                if ! command -v curl >/dev/null 2>&1; then
                    log_error "curl is required for update. Please install curl first."
                    exit 1
                fi

                # Check if git is available
                if ! command -v git >/dev/null 2>&1; then
                    log_error "git is required for update. Please install git first."
                    exit 1
                fi

                echo "üîÑ Fetching latest version from GitHub..."
                echo ""

                # Get latest commit hash from GitHub
                LATEST_COMMIT=$(get_latest_tfgrid_compose_version)
                if [ "$LATEST_COMMIT" = "unknown" ]; then
                    log_error "Failed to fetch latest commit from GitHub"
                    exit 1
                fi

                # Get current commit from our enhanced version detection
                CURRENT_VERSION_INFO=$(get_tfgrid_compose_version)
                CURRENT_COMMIT=$(echo "$CURRENT_VERSION_INFO" | jq -r '.git_commit // "unknown"')
                
                # Show detailed comparison
                echo "üìä Version Comparison:"
                echo "  Current commit: $CURRENT_COMMIT"
                echo "  Latest commit:  $LATEST_COMMIT"
                echo ""

                if [ "$CURRENT_COMMIT" = "$LATEST_COMMIT" ] || [ "$CURRENT_COMMIT" = "unknown" ] && [ -n "$LATEST_COMMIT" ]; then
                    if [ "$CURRENT_COMMIT" = "unknown" ]; then
                        echo "‚ö†Ô∏è  Current version detection failed, but update available"
                    else
                        echo "‚ú® Already at latest version: $LATEST_COMMIT"
                    fi
                    echo ""
                    echo "üß™ Test with: tfgrid-compose --version"
                    echo ""
                    exit 0
                fi

                echo "üìã Update Summary:"
                echo "  ‚Üí Current: $CURRENT_COMMIT"
                echo "  ‚Üí Latest:  $LATEST_COMMIT"
                echo ""

                # Check if dashboard is currently running so we can restart it after update
                DASHBOARD_WAS_RUNNING=false
                DASHBOARD_HOME="$HOME/.config/tfgrid-compose/dashboard"
                DASHBOARD_PID_FILE="$DASHBOARD_HOME/dashboard.pid"

                if [ -f "$DASHBOARD_PID_FILE" ]; then
                    DASHBOARD_PID=$(cat "$DASHBOARD_PID_FILE" 2>/dev/null || true)
                    if [ -n "$DASHBOARD_PID" ] && ps -p "$DASHBOARD_PID" >/dev/null 2>&1; then
                        DASHBOARD_WAS_RUNNING=true
                        log_info "Stopping running dashboard before update (pid $DASHBOARD_PID)..."
                        kill "$DASHBOARD_PID" 2>/dev/null || true
                        for i in $(seq 1 50); do
                            if ! ps -p "$DASHBOARD_PID" >/dev/null 2>&1; then
                                break
                            fi
                            sleep 0.1
                        done
                        rm -f "$DASHBOARD_PID_FILE"
                    else
                        rm -f "$DASHBOARD_PID_FILE"
                    fi
                fi

                # Create temp directory
                TEMP_DIR=$(mktemp -d)
                trap "rm -rf '$TEMP_DIR'" EXIT

                # Clone latest version
                if ! git clone --depth 1 https://github.com/tfgrid-studio/tfgrid-compose.git "$TEMP_DIR/tfgrid-compose" >/dev/null 2>&1; then
                    log_error "Failed to download latest version from GitHub"
                    exit 1
                fi

                echo "üì¶ Installing latest version..."

                # Update VERSION file with latest commit (maintain backwards compatibility)
                CURRENT_VERSION_FILE="$HOME/.config/tfgrid-compose/VERSION"
                echo "$LATEST_COMMIT" > "$CURRENT_VERSION_FILE"

                # Install the latest version
                cd "$TEMP_DIR/tfgrid-compose"
                if ! make install >/dev/null 2>&1; then
                    log_error "Failed to install latest version"
                    exit 1
                fi

                echo ""
                log_success "‚úÖ Successfully updated to latest version!"
                echo ""
                # Restart dashboard if it was running before the update
                if [ "$DASHBOARD_WAS_RUNNING" = true ]; then
                    log_info "Restarting TFGrid Studio dashboard with updated version..."
                    if command -v tfgrid-compose >/dev/null 2>&1; then
                        tfgrid-compose dashboard start >/dev/null 2>&1 || true
                    fi
                    echo ""
                fi

                echo "üîç Detection Method: Dynamic Git commit detection"
                echo "üß™ Test with: tfgrid-compose --version"
                echo ""
                echo "üí° Tip: Use 't update registry' to update apps + registry data"
                exit 0
                ;;
                
            --all-apps)
                # Update all cached apps
                log_info "TFGrid Compose v$VERSION - Update All Apps"
                echo ""
                
                log_info "Updating all cached apps..."
                refresh_outdated_apps
                
                echo ""
                log_success "‚úÖ App cache update complete!"
                ;;
                
            *)
                # Specific app update
                APP_NAME="$UPDATE_SUBCOMMAND"
                
                if [ -z "$APP_NAME" ]; then
                    log_error "Usage: tfgrid-compose update [registry|app-name|--all-apps]"
                    echo ""
                    echo "Update tfgrid-compose binary only (fast):"
                    echo "  tfgrid-compose update"
                    echo ""
                    echo "üéâ COMPREHENSIVE UPDATE (recommended):"
                    echo "  tfgrid-compose update registry"
                    echo "     ‚Üí Updates registry metadata + ALL cached apps"
                    echo ""
                    echo "Update specific app only:"
                    echo "  tfgrid-compose update tfgrid-ai-stack"
                    echo ""
                    echo "Update all cached apps only:"
                    echo "  tfgrid-compose update --all-apps"
                    exit 1
                fi
                
                log_info "TFGrid Compose $VERSION - Update App: $APP_NAME"
                echo ""
                
                # Check if app is cached
                if ! is_app_cached "$APP_NAME"; then
                    log_error "App '$APP_NAME' is not cached"
                    log_info "Deploy the app first or install it from registry"
                    exit 1
                fi
                
                # Get app information before update
                app_dir="$APPS_CACHE_DIR/$APP_NAME"
                cd "$app_dir" 2>/dev/null || true
                current_commit=$(git rev-parse --short=7 HEAD 2>/dev/null || echo "unknown")
                cd - >/dev/null
                
                echo "üìä Current Status:"
                echo "  App: $APP_NAME"
                echo "  Current commit: $current_commit"
                echo ""
                
                # Fetch latest commit from remote for comparison
                echo "üîÑ Fetching latest commits..."
                cd "$app_dir"
                fetch_result="unknown"
                if git fetch --quiet origin main 2>/dev/null; then
                    fetch_result=$(git rev-parse --short=7 origin/main 2>/dev/null || echo "unknown")
                elif git fetch --quiet origin master 2>/dev/null; then
                    fetch_result=$(git rev-parse --short=7 origin/master 2>/dev/null || echo "unknown")
                fi
                cd - >/dev/null
                
                if [ "$fetch_result" != "unknown" ]; then
                    echo "  Latest commit:  $fetch_result"
                    echo ""
                    
                    if [ "$current_commit" = "$fetch_result" ]; then
                        echo "‚ú® Already at latest version: $current_commit"
                        echo ""
                        echo "üß™ Test with: tfgrid-compose cache list"
                        exit 0
                    else
                        echo "üìã Update Available:"
                        echo "  ‚Üí Current: $current_commit"
                        echo "  ‚Üí Latest:  $fetch_result"
                        echo ""
                    fi
                else
                    echo "  Latest commit: Unable to fetch"
                    echo ""
                    log_warning "Could not fetch latest commits, attempting update anyway..."
                fi
                
                # Update the specific app
                if update_cached_app "$APP_NAME"; then
                    echo ""
                    log_success "‚úÖ Updated $APP_NAME successfully!"
                    echo ""
                    
                    # Show new commit after successful update
                    new_app_dir="$APPS_CACHE_DIR/$APP_NAME"
                    cd "$new_app_dir" 2>/dev/null || true
                    new_commit=$(git rev-parse --short=7 HEAD 2>/dev/null || echo "unknown")
                    cd - >/dev/null
                    
                    if [ "$new_commit" != "unknown" ]; then
                        echo "üîç New commit: $new_commit"
                        echo "üîç Detection Method: Git-based commit tracking"
                    fi
                    
                    echo ""
                    echo "üß™ Test with: tfgrid-compose cache list"
                    echo "üì± Deploy updated app: tfgrid-compose up $APP_NAME"
                else
                    echo ""
                    log_warning "‚ö†Ô∏è  Update failed for $APP_NAME (using cached version)"
                    echo ""
                    echo "üîß Troubleshooting:"
                    echo "  ‚Ä¢ Check network connectivity"
                    echo "  ‚Ä¢ Verify repository access: git ls-remote origin"
                    echo "  ‚Ä¢ Clear cache: tfgrid-compose cache clear $APP_NAME"
                    echo "  ‚Ä¢ Try manual update: cd ~/.config/tfgrid-compose/apps/$APP_NAME && git pull"
                fi
                ;;
        esac
        ;;
        
    cache)
        # Cache management command
        CACHE_SUBCOMMAND="${1:-status}"
        shift || true
        
        case "$CACHE_SUBCOMMAND" in
            status|health)
                # Show cache status
                log_info "TFGrid Compose v$VERSION - Cache Status"
                echo ""
                
                list_cached_apps_enhanced
                echo ""
                log_info "Run 't cache list' for detailed status"
                ;;
                
            list)
                # List all cached apps with detailed status
                log_info "TFGrid Compose v$VERSION - Cached Apps"
                echo ""
                
                list_cached_apps_enhanced
                echo ""
                log_info "Apps with [needs update] can be refreshed with 't update <app-name>'"
                ;;
                
            registry)
                # Show all registry apps status (cached and uncached)
                log_info "TFGrid Compose v$VERSION - Registry Apps Status"
                echo ""
                
                show_registry_apps_status
                ;;
                
            preload)
                # Pre-cache all registry apps
                log_info "TFGrid Compose v$VERSION - Pre-Cache Registry Apps"
                echo ""
                
                pre_cache_registry_apps
                ;;
                
            monitor)
                # Start cache monitoring dashboard
                log_info "TFGrid Compose v$VERSION - Cache Monitor"
                echo ""
                
                if [ -f "$DEPLOYER_ROOT/core/cache-dashboard.sh" ]; then
                    source "$DEPLOYER_ROOT/core/cache-dashboard.sh"
                    cache_dashboard_monitor "$@"
                else
                    log_error "Cache dashboard not found"
                    exit 1
                fi
                ;;
                
            dashboard)
                # Show cache health dashboard
                log_info "TFGrid Compose v$VERSION - Cache Dashboard"
                echo ""
                
                if [ -f "$DEPLOYER_ROOT/core/cache-dashboard.sh" ]; then
                    source "$DEPLOYER_ROOT/core/cache-dashboard.sh"
                    cache_dashboard_show
                else
                    log_error "Cache dashboard not found"
                    exit 1
                fi
                ;;
                
            outdated)
                # List apps that need updates
                log_info "TFGrid Compose v$VERSION - Outdated Apps"
                echo ""
                
                list_outdated_apps
                ;;
                
            refresh)
                # Refresh outdated apps automatically
                log_info "TFGrid Compose v$VERSION - Refresh Outdated Apps"
                echo ""
                
                refresh_outdated_apps
                ;;
                
            validate)
                # Validate cached apps
                log_info "TFGrid Compose v$VERSION - Validate Cache"
                echo ""
                
                app_name="$1"
                if [ -n "$app_name" ]; then
                    # Validate specific app
                    if validate_cached_app "$app_name"; then
                        echo "‚úÖ $app_name cache validation passed"
                    else
                        echo "‚ùå $app_name cache validation failed"
                        exit 1
                    fi
                else
                    # Validate all cached apps
                    echo "Validating all cached apps..."
                    echo ""
                    
                    failed_count=0
                    total_count=0
                    
                    for app_dir in "$APPS_CACHE_DIR"/*; do
                        if [ -d "$app_dir/.git" ] && [ -f "$app_dir/tfgrid-compose.yaml" ]; then
                            name=$(basename "$app_dir")
                            ((total_count++))
                            
                            if validate_cached_app "$name"; then
                                echo "‚úÖ $name"
                            else
                                echo "‚ùå $name"
                                ((failed_count++))
                            fi
                        fi
                    done
                    
                    echo ""
                    log_info "Validated $total_count apps, $failed_count failures"
                    
                    if [ $failed_count -gt 0 ]; then
                        exit 1
                    fi
                fi
                ;;
                
            clear)
                # Clean cache
                CACHE_TARGET="${1:-}"
                
                if [ -z "$CACHE_TARGET" ] || [ "$CACHE_TARGET" = "--all" ]; then
                    # Clear all cache
                    if [ "$CACHE_TARGET" = "--all" ]; then
                        log_info "Clearing ALL cache..."
                        clean_app_cache "" --force
                        log_success "All cache cleared"
                    else
                        echo "‚ö†Ô∏è  This will remove ALL cached apps"
                        echo "Apps will need to be downloaded again"
                        echo ""
                        read -p "Continue? (y/N): " -n 1 -r
                        echo
                        if [[ $REPLY =~ ^[Yy]$ ]]; then
                            clean_app_cache "" --force
                            log_success "All cache cleared"
                        else
                            log_info "Cancelled"
                        fi
                    fi
                else
                    # Clear specific app
                    clean_app_cache "$CACHE_TARGET"
                fi
                ;;
                
            info)
                # Show cache information
                log_info "TFGrid Compose v$VERSION - Cache Information"
                echo ""
                
                echo "Cache Directory: $APPS_CACHE_DIR"
                echo "Metadata Directory: $CACHE_METADATA_DIR"
                echo ""
                
                # Show cache statistics
                total_apps=0
                healthy_apps=0
                stale_apps=0
                invalid_apps=0
                
                for app_dir in "$APPS_CACHE_DIR"/*; do
                    if [ -d "$app_dir/.git" ] && [ -f "$app_dir/tfgrid-compose.yaml" ]; then
                        app_name=$(basename "$app_dir")
                        health=$(get_cache_health "$app_name")
                        status=$(echo "$health" | jq -r '.status')
                        
                        ((total_apps++))
                        case "$status" in
                            "healthy") ((healthy_apps++)) ;;
                            "stale") ((stale_apps++)) ;;
                            "invalid") ((invalid_apps++)) ;;
                        esac
                    fi
                done
                
                echo "Cache Statistics:"
                echo "  Total apps: $total_apps"
                echo "  Healthy: $healthy_apps"
                echo "  Stale: $stale_apps"
                echo "  Invalid: $invalid_apps"
                echo ""
                
                log_info "Use 't cache list' for detailed status"
                ;;
                
            --help|-h|"")
                # Show help
                echo ""
                echo "üîÑ Cache Management"
                echo ""
                echo "Usage: tfgrid-compose cache <subcommand> [options]"
                echo ""
                echo "Subcommands:"
                echo "  status, health      Show cache overview"
                echo "  list               List all cached apps with status"
                echo "  registry           Show all registry apps (cached/uncached)"
                echo "  preload            Pre-cache all registry apps"
                echo "  monitor            Start real-time cache monitoring dashboard"
                echo "  dashboard          Show cache health analytics dashboard"
                echo "  outdated           List apps needing updates"
                echo "  refresh            Auto-refresh outdated apps"
                echo "  validate           Validate cached apps"
                echo "  clear [app-name]   Clear cache (specific app or all)"
                echo "  info               Show cache information"
                echo ""
                echo "Examples:"
                echo "  t cache status                     # Show cache overview"
                echo "  t cache list                       # List all cached apps"
                echo "  t cache registry                   # Show all registry apps"
                echo "  t cache preload                    # Cache all registry apps"
                echo "  t cache monitor                    # Start monitoring dashboard"
                echo "  t cache outdated                   # Show apps needing updates"
                echo "  t cache refresh                    # Auto-refresh outdated apps"
                echo "  t cache validate tfgrid-ai-stack  # Validate specific app"
                echo "  t cache clear tfgrid-ai-stack     # Remove specific app from cache"
                echo "  t cache clear --all                # Clear ALL cache"
                echo ""
                exit 0
                ;;
                
            *)
                log_error "Unknown cache subcommand: $CACHE_SUBCOMMAND"
                log_info "Use 'tfgrid-compose cache --help' to see available commands"
                exit 1
                ;;
        esac
        ;;

    signin)
        # Signin command - always use tfgrid-compose version
        # Apps don't have signin commands, only login commands
        cmd_signin "$@"
        ;;


    signout)
        # Signout command
        cmd_signout
        ;;

    config)
        # Config command
        case "$1" in
            init)
                # Initialize configuration
                init_config
                ;;
            show|"")
                # Show current configuration or interactive mode
                if [ -z "$1" ]; then
                    # Interactive mode when no subcommand
                    echo ""
                    echo "üìã TFGrid Compose Configuration"
                    echo ""
                    echo "Current configuration:"
                    show_config
                    echo ""
                    echo "What would you like to do?"
                    echo "  1) Set a configuration value"
                    echo "  2) Get a configuration value"
                    echo "  3) Initialize/reset configuration"
                    echo "  4) Show current configuration (detailed)"
                    echo "  5) Exit"
                    echo ""
                    read -p "Enter choice [1-5]: " choice

                    case $choice in
                        1)
                            # Interactive set
                            echo ""
                            echo "Available configuration keys:"
                            echo "  1) blacklist_nodes     - Comma-separated list of nodes to avoid"
                            echo "  2) blacklist_farms     - Comma-separated list of farms to avoid"
                            echo "  3) whitelist_farms     - Comma-separated list of preferred farms"
                            echo "  4) max_cpu_usage       - Maximum CPU usage percentage (0-100)"
                            echo "  5) max_disk_usage      - Maximum disk usage percentage (0-100)"
                            echo "  6) min_uptime_days     - Minimum uptime in days"
                            echo ""
                            read -p "Enter key name or number [1-6]: " key_input
                            if [ -z "$key_input" ]; then
                                log_error "No key provided"
                                exit 1
                            fi

                            # Convert number to key name
                            case "$key_input" in
                                1) key_name="blacklist_nodes" ;;
                                2) key_name="blacklist_farms" ;;
                                3) key_name="whitelist_farms" ;;
                                4) key_name="max_cpu_usage" ;;
                                5) key_name="max_disk_usage" ;;
                                6) key_name="min_uptime_days" ;;
                                *) key_name="$key_input" ;;
                            esac

                            read -p "Enter value for '$key_name': " key_value
                            if [ -z "$key_value" ]; then
                                log_error "No value provided"
                                exit 1
                            fi
                            config_set "$key_name" "$key_value"
                            ;;
                        2)
                            # Interactive get
                            echo ""
                            echo "Available configuration keys:"
                            echo "  1) blacklist_nodes"
                            echo "  2) blacklist_farms"
                            echo "  3) whitelist_farms"
                            echo "  4) max_cpu_usage"
                            echo "  5) max_disk_usage"
                            echo "  6) min_uptime_days"
                            echo ""
                            read -p "Enter key name or number [1-6]: " key_input
                            if [ -z "$key_input" ]; then
                                log_error "No key provided"
                                exit 1
                            fi

                            # Convert number to key name
                            case "$key_input" in
                                1) key_name="blacklist_nodes" ;;
                                2) key_name="blacklist_farms" ;;
                                3) key_name="whitelist_farms" ;;
                                4) key_name="max_cpu_usage" ;;
                                5) key_name="max_disk_usage" ;;
                                6) key_name="min_uptime_days" ;;
                                *) key_name="$key_input" ;;
                            esac

                            VALUE=$(config_get "$key_name")
                            if [ -n "$VALUE" ]; then
                                echo ""
                                log_success "Configuration '$key_name' = $VALUE"
                            else
                                log_info "Configuration key '$key_name' not found (value not set)"
                            fi
                            ;;
                        3)
                            # Initialize/reset
                            echo ""
                            read -p "This will reset all configuration to defaults. Continue? (y/N): " confirm
                            if [[ $confirm =~ ^[Yy]$ ]]; then
                                # Remove existing config and reinitialize
                                rm -f "$HOME/.config/tfgrid-compose/config.yaml"
                                init_config
                            else
                                echo "Cancelled."
                            fi
                            ;;
                        4)
                            # Show detailed
                            echo ""
                            show_config
                            ;;
                        5)
                            # Exit
                            echo ""
                            log_info "Goodbye!"
                            ;;
                        *)
                            log_error "Invalid choice"
                            exit 1
                            ;;
                    esac
                else
                    # Show current configuration
                    show_config
                fi
                ;;
            set)
                # Set configuration value
                if [ -z "$2" ] || [ -z "$3" ]; then
                    log_error "Usage: tfgrid-compose config set <key> <value>"
                    exit 1
                fi
                config_set "$2" "$3"
                ;;
            get)
                # Get configuration value
                if [ -z "$2" ]; then
                    log_error "Usage: tfgrid-compose config get <key>"
                    exit 1
                fi
                VALUE=$(config_get "$2")
                if [ -n "$VALUE" ]; then
                    echo "$VALUE"
                else
                    log_info "Configuration key '$2' not found"
                fi
                ;;
            *)
                log_error "Unknown config subcommand: $1"
                log_info "Available: init, show, set, get"
                exit 1
                ;;
        esac
        ;;

    docs)
        # Documentation command
        DOCS_URL="https://docs.tfgrid.studio"
        
        echo ""
        echo "üìö TFGrid Compose Documentation"
        echo ""
        echo "‚Üí $DOCS_URL"
        echo ""
        
        sleep 0.5
        
        # Try to open in browser
        if command -v xdg-open &> /dev/null; then
            echo "Opening in browser..."
            sleep 0.5
            xdg-open "$DOCS_URL" >/dev/null 2>&1 &
            disown
            echo ""
            echo "‚úì Done"
        elif command -v open &> /dev/null; then
            echo "Opening in browser..."
            sleep 0.5
            open "$DOCS_URL" >/dev/null 2>&1 &
            echo "‚úì Done"
        else
            echo "‚Ñπ  Copy the URL above to open in your browser"
        fi
        echo ""
        ;;

    shortcut)
        # Shortcut command - create/manage command shortcuts
        SHORTCUT_NAME="$1"
        
        # Handle subcommands
        case "$SHORTCUT_NAME" in
            --list|-l)
                # List all shortcuts
                echo ""
                echo "üîó Active shortcuts:"
                echo ""
                
                FOUND=false
                for file in "$HOME/.local/bin"/*; do
                    if [ -L "$file" ] && [ "$(readlink "$file")" = "$HOME/.local/bin/tfgrid-compose" ]; then
                        echo "  ‚Ä¢ $(basename "$file") -> tfgrid-compose"
                        FOUND=true
                    fi
                done
                
                if [ "$FOUND" = "false" ]; then
                    echo "  (no shortcuts configured)"
                fi
                echo ""
                exit 0
                ;;
                
            --remove|-r)
                # Remove shortcut
                REMOVE_NAME="$2"
                if [ -z "$REMOVE_NAME" ]; then
                    log_error "Usage: tfgrid-compose shortcut --remove <name>"
                    exit 1
                fi
                
                # Don't allow removing tfgrid-compose itself
                if [ "$REMOVE_NAME" = "tfgrid-compose" ]; then
                    log_error "Cannot remove tfgrid-compose (main command)"
                    exit 1
                fi
                
                SHORTCUT_PATH="$HOME/.local/bin/$REMOVE_NAME"
                
                if [ ! -L "$SHORTCUT_PATH" ]; then
                    log_error "Shortcut '$REMOVE_NAME' does not exist"
                    exit 1
                fi
                
                if [ "$(readlink "$SHORTCUT_PATH")" != "$HOME/.local/bin/tfgrid-compose" ]; then
                    log_error "'$REMOVE_NAME' is not a tfgrid-compose shortcut"
                    exit 1
                fi
                
                rm "$SHORTCUT_PATH"
                log_success "Removed shortcut: $REMOVE_NAME"
                exit 0
                ;;
                
            --default|-d)
                # Reset to default (tfgrid)
                SHORTCUT_PATH="$HOME/.local/bin/tfgrid"
                
                if [ -L "$SHORTCUT_PATH" ] && [ "$(readlink "$SHORTCUT_PATH")" = "$HOME/.local/bin/tfgrid-compose" ]; then
                    log_info "Default shortcut 'tfgrid' already exists"
                else
                    ln -sf "$HOME/.local/bin/tfgrid-compose" "$SHORTCUT_PATH"
                    log_success "Created default shortcut: tfgrid"
                fi
                exit 0
                ;;
                
            --help|-h)
                # Show help
                echo ""
                echo "üîó Shortcut Management"
                echo ""
                echo "Usage:"
                echo "  tfgrid-compose shortcut               Interactive mode"
                echo "  tfgrid-compose shortcut <name>        Create shortcut"
                echo "  tfgrid-compose shortcut --list        List all shortcuts"
                echo "  tfgrid-compose shortcut --remove <name>  Remove shortcut"
                echo "  tfgrid-compose shortcut --default     Reset to 'tfgrid'"
                echo ""
                echo "Examples:"
                echo "  tfgrid-compose shortcut               # Interactive menu"
                echo "  tfgrid-compose shortcut tf            # Create 'tf' shortcut"
                echo "  tfgrid-compose shortcut grid          # Create 'grid' shortcut"
                echo "  tfgrid-compose shortcut --list        # Show all shortcuts"
                echo "  tfgrid-compose shortcut --remove tf   # Remove 'tf' shortcut"
                echo ""
                exit 0
                ;;
                
            "")
                # Interactive mode (no arguments)
                echo ""
                echo "üîó Shortcut Management (Interactive)"
                echo ""
                
                # Show current shortcuts
                echo "Current shortcuts:"
                FOUND=false
                for file in "$HOME/.local/bin"/*; do
                    if [ -L "$file" ] && [ "$(readlink "$file")" = "$HOME/.local/bin/tfgrid-compose" ]; then
                        echo "  ‚Ä¢ $(basename "$file")"
                        FOUND=true
                    fi
                done
                
                if [ "$FOUND" = "false" ]; then
                    echo "  (none configured)"
                fi
                echo ""
                
                # Interactive menu
                echo "What would you like to do?"
                echo "  1) Create a new shortcut"
                echo "  2) Remove a shortcut"
                echo "  3) List all shortcuts (detailed)"
                echo "  4) Reset to default (tfgrid)"
                echo "  5) Exit"
                echo ""
                
                read -p "Enter choice [1-5]: " choice
                
                case $choice in
                    1)
                        # Create shortcut
                        echo ""
                        echo "Popular choices: tf, grid, tfc"
                        read -p "Enter shortcut name: " new_name
                        
                        if [ -z "$new_name" ]; then
                            log_error "No name provided"
                            exit 1
                        fi
                        
                        # Validate shortcut name
                        if [[ ! "$new_name" =~ ^[a-zA-Z][a-zA-Z0-9_-]*$ ]]; then
                            log_error "Invalid shortcut name: $new_name"
                            log_info "Name must start with a letter and contain only letters, numbers, hyphens, and underscores"
                            exit 1
                        fi
                        
                        # Don't allow overwriting tfgrid-compose itself
                        if [ "$new_name" = "tfgrid-compose" ]; then
                            log_error "Cannot use 'tfgrid-compose' as shortcut name"
                            exit 1
                        fi
                        
                        # Check if command already exists in PATH
                        if command -v "$new_name" &> /dev/null; then
                            EXISTING_CMD=$(command -v "$new_name")
                            # Skip warning if it's already our shortcut
                            if [ ! -L "$EXISTING_CMD" ] || [ "$(readlink "$EXISTING_CMD")" != "$HOME/.local/bin/tfgrid-compose" ]; then
                                echo ""
                                log_warning "Command '$new_name' already exists!"
                                log_info "Existing command: $EXISTING_CMD"
                                log_info "Creating this shortcut will shadow the existing command"
                                echo ""
                                read -p "Continue anyway? (y/N): " confirm
                                if [[ ! $confirm =~ ^[Yy]$ ]]; then
                                    echo ""
                                    log_info "Cancelled - shortcut not created"
                                    echo ""
                                    exit 0
                                fi
                            fi
                        fi
                        
                        SHORTCUT_PATH="$HOME/.local/bin/$new_name"
                        
                        # Warn if shortcut already exists
                        if [ -e "$SHORTCUT_PATH" ]; then
                            if [ -L "$SHORTCUT_PATH" ] && [ "$(readlink "$SHORTCUT_PATH")" = "$HOME/.local/bin/tfgrid-compose" ]; then
                                log_info "Shortcut '$new_name' already exists"
                                exit 0
                            else
                                log_error "File '$new_name' already exists in ~/.local/bin"
                                log_info "Choose a different name"
                                exit 1
                            fi
                        fi
                        
                        # Create symlink
                        ln -s "$HOME/.local/bin/tfgrid-compose" "$SHORTCUT_PATH"
                        echo ""
                        log_success "Created shortcut: $new_name"
                        echo ""
                        log_info "You can now use: $new_name <command>"
                        echo ""
                        ;;
                        
                    2)
                        # Remove shortcut
                        echo ""
                        read -p "Enter shortcut name to remove: " remove_name
                        
                        if [ -z "$remove_name" ]; then
                            log_error "No name provided"
                            exit 1
                        fi
                        
                        # Don't allow removing tfgrid-compose itself
                        if [ "$remove_name" = "tfgrid-compose" ]; then
                            log_error "Cannot remove tfgrid-compose (main command)"
                            exit 1
                        fi
                        
                        SHORTCUT_PATH="$HOME/.local/bin/$remove_name"
                        
                        if [ ! -L "$SHORTCUT_PATH" ]; then
                            log_error "Shortcut '$remove_name' does not exist"
                            exit 1
                        fi
                        
                        if [ "$(readlink "$SHORTCUT_PATH")" != "$HOME/.local/bin/tfgrid-compose" ]; then
                            log_error "'$remove_name' is not a tfgrid-compose shortcut"
                            exit 1
                        fi
                        
                        rm "$SHORTCUT_PATH"
                        echo ""
                        log_success "Removed shortcut: $remove_name"
                        echo ""
                        ;;
                        
                    3)
                        # List shortcuts (detailed)
                        echo ""
                        echo "üîó Active shortcuts:"
                        echo ""
                        
                        FOUND=false
                        for file in "$HOME/.local/bin"/*; do
                            if [ -L "$file" ] && [ "$(readlink "$file")" = "$HOME/.local/bin/tfgrid-compose" ]; then
                                echo "  ‚Ä¢ $(basename "$file") -> tfgrid-compose"
                                FOUND=true
                            fi
                        done
                        
                        if [ "$FOUND" = "false" ]; then
                            echo "  (no shortcuts configured)"
                        fi
                        echo ""
                        ;;
                        
                    4)
                        # Reset to default
                        echo ""
                        SHORTCUT_PATH="$HOME/.local/bin/tfgrid"
                        
                        if [ -L "$SHORTCUT_PATH" ] && [ "$(readlink "$SHORTCUT_PATH")" = "$HOME/.local/bin/tfgrid-compose" ]; then
                            log_info "Default shortcut 'tfgrid' already exists"
                        else
                            ln -sf "$HOME/.local/bin/tfgrid-compose" "$SHORTCUT_PATH"
                            log_success "Created default shortcut: tfgrid"
                        fi
                        echo ""
                        ;;
                        
                    5)
                        # Exit
                        echo ""
                        log_info "Goodbye!"
                        echo ""
                        exit 0
                        ;;
                        
                    *)
                        log_error "Invalid choice"
                        exit 1
                        ;;
                esac
                
                exit 0
                ;;
                
            *)
                # Create new shortcut
                if [ -z "$SHORTCUT_NAME" ]; then
                    log_error "Usage: tfgrid-compose shortcut <name>"
                    log_info "Try: tfgrid-compose shortcut --help"
                    exit 1
                fi
                
                # Validate shortcut name
                if [[ ! "$SHORTCUT_NAME" =~ ^[a-zA-Z][a-zA-Z0-9_-]*$ ]]; then
                    log_error "Invalid shortcut name: $SHORTCUT_NAME"
                    log_info "Name must start with a letter and contain only letters, numbers, hyphens, and underscores"
                    exit 1
                fi
                
                # Don't allow overwriting tfgrid-compose itself
                if [ "$SHORTCUT_NAME" = "tfgrid-compose" ]; then
                    log_error "Cannot use 'tfgrid-compose' as shortcut name"
                    exit 1
                fi
                
                # Check if command already exists in PATH
                if command -v "$SHORTCUT_NAME" &> /dev/null; then
                    EXISTING_CMD=$(command -v "$SHORTCUT_NAME")
                    # Skip warning if it's already our shortcut
                    if [ ! -L "$EXISTING_CMD" ] || [ "$(readlink "$EXISTING_CMD")" != "$HOME/.local/bin/tfgrid-compose" ]; then
                        echo ""
                        log_warning "Command '$SHORTCUT_NAME' already exists!"
                        log_info "Existing command: $EXISTING_CMD"
                        log_info "Creating this shortcut will shadow the existing command"
                        echo ""
                        read -p "Continue anyway? (y/N): " confirm
                        if [[ ! $confirm =~ ^[Yy]$ ]]; then
                            echo ""
                            log_info "Cancelled - shortcut not created"
                            echo ""
                            exit 0
                        fi
                    fi
                fi
                
                SHORTCUT_PATH="$HOME/.local/bin/$SHORTCUT_NAME"
                
                # Warn if shortcut already exists
                if [ -e "$SHORTCUT_PATH" ]; then
                    if [ -L "$SHORTCUT_PATH" ] && [ "$(readlink "$SHORTCUT_PATH")" = "$HOME/.local/bin/tfgrid-compose" ]; then
                        log_info "Shortcut '$SHORTCUT_NAME' already exists"
                        exit 0
                    else
                        log_error "File '$SHORTCUT_NAME' already exists in ~/.local/bin"
                        log_info "Choose a different name"
                        exit 1
                    fi
                fi
                
                # Create symlink
                ln -s "$HOME/.local/bin/tfgrid-compose" "$SHORTCUT_PATH"
                
                echo ""
                log_success "Created shortcut: $SHORTCUT_NAME"
                echo ""
                log_info "You can now use: $SHORTCUT_NAME <command>"
                echo ""
                log_info "Example: $SHORTCUT_NAME up"
                echo ""
                
                exit 0
                ;;
        esac
        ;;

    network)
        # Network management command
        log_command "Network Management"

        network_subcommand "$@"
        exit $?
        ;;

    nodes)
        # Interactive node browser with farm filtering support
        NODES_FARM=""

        # Parse --farm parameter for nodes command
        while [[ $# -gt 0 ]]; do
            case $1 in
                --farm)
                    NODES_FARM="$2"
                    shift 2
                    ;;
                --farm=*)
                    NODES_FARM="${1#--farm=}"
                    shift
                    ;;
                *)
                    # Pass other arguments to nodes_command
                    break
                    ;;
            esac
        done

        # Export farm filter for nodes_command
        export NODES_FARM_FILTER="$NODES_FARM"

        # Call nodes_command with remaining arguments
        nodes_command "$@"
        ;;

    update-git-config)
        # Update git config on running VM
        update_git_config "$1"
        ;;

    version|--version|-v)
        # Version command
        echo "TFGrid Compose v$VERSION"
        ;;

    help|--help|-h|"")
        # Help command
        echo ""
        display_version
        echo ""
        show_help
        ;;
    tfcmd-install)
        # Install tfcmd from GitHub releases
        log_info "TFGrid Compose v$VERSION - Install tfcmd"
        echo ""

        echo "üì• Installing tfcmd from GitHub releases..."
        echo ""

        # Check for required tools
        if ! command -v curl >/dev/null 2>&1; then
            log_error "curl is required. Please install curl first."
            exit 1
        fi

        # Detect architecture (for logging only)
        ARCH=$(uname -m)
        case "$ARCH" in
            x86_64)
                echo "Architecture: amd64"
                ;;
            aarch64|arm64)
                echo "Architecture: arm64"
                ;;
            *)
                log_warning "Unsupported architecture: $ARCH, will try to find any available binary"
                ;;
        esac

        # Try to get latest release version, fallback to known version
        LATEST_RELEASE_URL="https://api.github.com/repos/threefoldtech/tfgrid-sdk-go/releases/latest"
        echo "Fetching latest release info..."
        
        LATEST_VERSION=$(curl -s "$LATEST_RELEASE_URL" | grep '"tag_name"' | sed -E 's/.*"([^"]+)".*/\1/' 2>/dev/null)
        
        if [ -z "$LATEST_VERSION" ]; then
            log_warning "Could not fetch latest release, using fallback version"
            LATEST_VERSION="v0.17.0"  # Known working version as fallback
        fi

        echo "Latest version: $LATEST_VERSION"
        echo ""

        # Download the correct tarball containing tfcmd
        DOWNLOAD_URL="https://github.com/threefoldtech/tfgrid-sdk-go/releases/download/${LATEST_VERSION}/tfgrid-sdk-go_Linux_x86_64.tar.gz"
        
        echo "Downloading from: tfgrid-sdk-go_Linux_x86_64.tar.gz"

        # Download and extract the tarball
        TMP_DIR="$HOME/.local/share/tfgrid-compose/tmp"
        mkdir -p "$TMP_DIR"
        TMP_FILE="$TMP_DIR/tfgrid-sdk-go.tar.gz"
        
        echo "Downloading tarball..."
        if curl -L -o "$TMP_FILE" "$DOWNLOAD_URL" 2>/dev/null && [ -s "$TMP_FILE" ]; then
            echo "Extracting tfcmd binary..."
            cd "$TMP_DIR"
            
            # Extract the tarball
            if tar -xzf "$TMP_FILE" 2>/dev/null; then
                # Look for tfcmd binary in extracted files
                TFCMD_BIN=$(find . -name "tfcmd" -type f 2>/dev/null | head -1)
                if [ -n "$TFCMD_BIN" ] && [ -f "$TFCMD_BIN" ]; then
                    TMP_FILE="$TFCMD_BIN"
                    echo "‚úÖ Extracted tfcmd binary"
                else
                    echo "Available files in tarball:"
                    tar -tzf "$TMP_FILE" | head -10
                    log_error "Could not find tfcmd binary in tarball"
                    exit 1
                fi
            else
                log_error "Failed to extract tarball"
                exit 1
            fi
        else
            log_error "Failed to download tarball"
            exit 1
        fi

        # Validate and install the binary
        chmod +x "$TMP_FILE"
        
        # Check if the binary is actually executable
        if ! "$TMP_FILE" --version >/dev/null 2>&1 && ! "$TMP_FILE" --help >/dev/null 2>&1; then
            # Try to see what type of file it is
            FILE_TYPE=$(file "$TMP_FILE" 2>/dev/null)
            echo ""
            log_warning "Downloaded file may not be a valid tfcmd binary"
            echo "File type: $FILE_TYPE"
            echo ""
            echo "This might be a corrupt download or wrong file format."
            echo "Please try again or download manually from:"
            echo "  https://github.com/threefoldtech/tfgrid-sdk-go/releases"
            exit 1
        fi
        
        if [ "$EUID" -eq 0 ]; then
            # Running as root, install directly to system location
            mv "$TMP_FILE" /usr/local/bin/tfcmd
            echo ""
            log_success "‚úÖ tfcmd installed successfully!"
            echo ""
            echo "Installed at: /usr/local/bin/tfcmd"
            echo ""
            echo "Ready to use! Run:"
            echo "  tfgrid-compose tfcmd-login"
        else
            # Not root, install to user-local bin directory
            LOCAL_BIN="$HOME/.local/bin"
            mkdir -p "$LOCAL_BIN"
            mv "$TMP_FILE" "$LOCAL_BIN/tfcmd"
            
            # Check if already in PATH and add to session if needed
            if [[ ":$PATH:" != *":$LOCAL_BIN:"* ]]; then
                echo ""
                log_info "Adding $LOCAL_BIN to PATH for this session..."
                export PATH="$LOCAL_BIN:$PATH"
                echo ""
                echo "To make this permanent, add this line to your ~/.bashrc or ~/.zshrc:"
                echo "  export PATH=\"\$HOME/.local/bin:\$PATH\""
                echo ""
            else
                echo ""
                log_info "$LOCAL_BIN already in PATH"
            fi
            
            echo ""
            log_success "‚úÖ tfcmd installed successfully!"
            echo ""
            echo "Installed at: $LOCAL_BIN/tfcmd"
            echo ""
            echo "Ready to use! Run:"
            echo "  tfgrid-compose tfcmd-login"
        fi
        
        echo ""
        echo "Next steps:"
        echo "  tfgrid-compose tfcmd-login"
        echo "  tfgrid-compose contracts list"
        ;;
    
    get)
        # Direct tfcmd wrapper - get resources
        RESOURCE="${1:-}"
        shift || true

        case "$RESOURCE" in
            contracts)
                # List contracts using tfcmd
                log_info "TFGrid Compose v$VERSION - Contract List"
                echo ""

                # Parse options (simplified)
                FORMAT="table"

                while [[ $# -gt 0 ]]; do
                    case "$1" in
                        --format=*)
                            FORMAT="${1#--format=}"
                            ;;
                        *)
                            log_error "Unknown option: $1"
                            echo ""
                            echo "Usage: tfgrid-compose get contracts [--format FORMAT]"
                            echo ""
                            echo "Options:"
                            echo "  --format=FORMAT   Output format: table, json, csv [default: table]"
                            exit 1
                            ;;
                    esac
                    shift
                done

                # Ensure tfcmd is ready and get contracts
                if ! ensure_tfcmd_login; then
                    exit 1
                fi

                # Get contracts using tfcmd
                CONTRACTS_JSON=$(contracts_list_tfcmd)
                if [ $? -ne 0 ]; then
                    log_error "Failed to fetch contracts"
                    exit 1
                fi

                # Format and display (let tfcmd handle formatting)
                format_contract_output "$CONTRACTS_JSON" "$FORMAT"
                ;;
            contract)
                # Show single contract details
                CONTRACT_ID="$1"

                if [ -z "$CONTRACT_ID" ]; then
                    log_error "Contract ID required"
                    echo ""
                    echo "Usage: tfgrid-compose get contract <contract-id>"
                    exit 1
                fi

                if ! validate_contract_id "$CONTRACT_ID"; then
                    exit 1
                fi

                log_info "Fetching contract details for ID: $CONTRACT_ID"

                # Get contract details using tfcmd
                if ! ensure_tfcmd_login; then
                    exit 1
                fi

                CONTRACT_JSON=$(contracts_get_details_tfcmd "$CONTRACT_ID")
                if [ $? -ne 0 ]; then
                    log_error "Failed to fetch contract details"
                    exit 1
                fi

                # Display formatted details
                echo "$CONTRACT_JSON"
                ;;
            *)
                log_error "Unknown resource: $RESOURCE"
                echo ""
                echo "Available resources:"
                echo "  contracts     List all contracts"
                echo "  contract      Show contract details"
                echo ""
                echo "Usage: tfgrid-compose get <resource> [options]"
                exit 1
                ;;
        esac

        exit 0
        ;;
    delete)
        # Direct tfcmd wrapper - delete resources
        RESOURCE="${1:-}"
        shift || true

        case "$RESOURCE" in
            contracts)
                # Delete/cancel contracts using tfcmd
                if [ $# -eq 0 ]; then
                    log_error "Contract ID(s) required"
                    echo ""
                    echo "Usage: tfgrid-compose delete contracts <contract-id> [contract-id ...]"
                    echo "       tfgrid-compose delete contracts --all"
                    exit 1
                fi

                # Parse options (simplified)
                FORCE=false
                IS_ALL=false
                CONTRACT_IDS=()

                while [[ $# -gt 0 ]]; do
                    case "$1" in
                        --force|-f)
                            FORCE=true
                            shift
                            ;;
                        --all)
                            IS_ALL=true
                            shift
                            ;;
                        -*)
                            log_error "Unknown option: $1"
                            exit 1
                            ;;
                        *)
                            # Collect contract IDs
                            CONTRACT_IDS+=("$1")
                            shift
                            ;;
                    esac
                done

                # Validate arguments
                if [ "$IS_ALL" = true ] && [ ${#CONTRACT_IDS[@]} -gt 0 ]; then
                    log_error "Cannot use --all with specific contract IDs"
                    exit 1
                fi

                if [ "$IS_ALL" = false ] && [ ${#CONTRACT_IDS[@]} -eq 0 ]; then
                    echo ""
                    echo "Usage: tfgrid-compose delete contracts [options] <contract-id> [<contract-id> ...]"
                    echo "       tfgrid-compose delete contracts --all"
                    echo ""
                    echo "Options:"
                    echo "  --force, -f       Skip confirmation prompt"
                    echo "  --all             Cancel all contracts"
                    exit 1
                fi

                # Ensure tfcmd is ready
                if ! ensure_tfcmd_login; then
                    exit 1
                fi

                # Confirm cancellation unless forced
                if [ "$FORCE" != true ]; then
                    if [ "$IS_ALL" = true ]; then
                        echo ""
                        echo "‚ö†Ô∏è  WARNING: This will cancel ALL contracts!"
                        echo ""
                        echo "This action cannot be undone."
                        echo ""
                        echo -n "Are you sure you want to cancel ALL contracts? (yes/no): "
                        read -r confirm
                        
                        if [ "$confirm" != "yes" ]; then
                            echo "Cancelled"
                            exit 1
                        fi
                    else
                        echo ""
                        echo "‚ö†Ô∏è  This will cancel the following contracts:"
                        for id in "${CONTRACT_IDS[@]}"; do
                            echo "  - $id"
                        done
                        echo ""
                        echo "This action cannot be undone."
                        echo ""
                        echo -n "Are you sure? (yes/no): "
                        read -r confirm
                        
                        if [ "$confirm" != "yes" ]; then
                            echo "Cancelled"
                            exit 1
                        fi
                    fi
                fi

                # Perform cancellation using tfcmd
                if [ "$IS_ALL" = true ]; then
                    if contracts_cancel_batch_tfcmd "--all"; then
                        exit 0
                    else
                        exit 1
                    fi
                else
                    # Validate all contract IDs first
                    for id in "${CONTRACT_IDS[@]}"; do
                        if ! validate_contract_id "$id"; then
                            exit 1
                        fi
                    done
                    
                    local ids_string=$(printf '%s\n' "${CONTRACT_IDS[@]}" | tr '\n' ' ')
                    if contracts_cancel_batch_tfcmd "$ids_string"; then
                        exit 0
                    else
                        exit 1
                    fi
                fi
                ;;
            contract)
                # Delete single contract
                CONTRACT_ID="$1"

                if [ -z "$CONTRACT_ID" ]; then
                    log_error "Contract ID required"
                    echo ""
                    echo "Usage: tfgrid-compose delete contract <contract-id> [--force]"
                    exit 1
                fi

                if ! validate_contract_id "$CONTRACT_ID"; then
                    exit 1
                fi

                # Parse options
                FORCE=false
                while [[ $# -gt 0 ]]; do
                    case "$1" in
                        --force|-f)
                            FORCE=true
                            shift
                            ;;
                        *)
                            log_error "Unknown option: $1"
                            exit 1
                            ;;
                    esac
                done

                # Ensure tfcmd is ready
                if ! ensure_tfcmd_login; then
                    exit 1
                fi

                # Confirm deletion unless forced
                if [ "$FORCE" != true ]; then
                    echo ""
                    echo "‚ö†Ô∏è  This will cancel contract $CONTRACT_ID"
                    echo "This action cannot be undone."
                    echo ""
                    echo -n "Are you sure? (yes/no): "
                    read -r confirm
                    
                    if [ "$confirm" != "yes" ]; then
                        echo "Cancelled"
                        exit 1
                    fi
                fi

                # Delete single contract
                if contracts_cancel_single_tfcmd "$CONTRACT_ID"; then
                    exit 0
                else
                    exit 1
                fi
                ;;
            *)
                log_error "Unknown resource: $RESOURCE"
                echo ""
                echo "Available resources:"
                echo "  contracts     Delete contracts (single or batch)"
                echo "  contract      Delete single contract"
                echo ""
                echo "Usage: tfgrid-compose delete <resource> [options] <id...>"
                exit 1
                ;;
        esac

        exit 0
        ;;
    contracts)
        # Simple tfcmd wrapper for contract management
        SUBCOMMAND="${1:-list}"
        shift || true

        case "$SUBCOMMAND" in
            list)
                # List contracts using simple wrapper
                contracts_list
                ;;
            show)
                # Show contract details (not implemented in simple wrapper)
                echo "Contract details not implemented in simple wrapper"
                echo "Use: tfcmd get contract <contract-id>"
                exit 1
                ;;
            delete)
                # Delete single contract using simple wrapper
                CONTRACT_ID="$1"
                
                if [ -z "$CONTRACT_ID" ]; then
                    echo ""
                    echo "Usage: tfgrid-compose contracts delete <contract-id>"
                    exit 1
                fi
                
                contracts_delete "$CONTRACT_ID"
                ;;
            cancel-all)
                # Cancel all contracts using simple wrapper
                contracts_cancel_all
                ;;
            *)
                log_error "Unknown contracts subcommand: $SUBCOMMAND"
                echo ""
                echo "Available subcommands:"
                echo "  list       List all contracts (via tfcmd)"
                echo "  show       Show contract details (coming soon)"
                echo "  delete     Delete single contract (wraps tfcmd cancel)"
                echo "  cancel-all Cancel ALL contracts (‚ö†Ô∏è DANGEROUS!)"
                echo ""
                echo "First time setup:"
                echo "  1. tfgrid-compose tfcmd-install    # Install tfcmd"
                echo "  2. tfgrid-compose signin           # Set up credentials"
                echo "  3. tfgrid-compose contracts list   # View contracts"
                echo ""
                echo "Usage: tfgrid-compose contracts <subcommand> [options]"
                exit 1
                ;;
        esac

        exit 0
        ;;
        
    whitelist|wl)
        # Whitelist command - manage preferred nodes/farms
        log_info "TFGrid Compose v$VERSION - Whitelist Management"
        echo ""
        
        cmd_whitelist "$@"
        exit $?
        ;;
        
    blacklist|bl)
        # Blacklist command - manage nodes/farms to avoid
        log_info "TFGrid Compose v$VERSION - Blacklist Management"
        echo ""
        
        cmd_blacklist "$@"
        exit $?
        ;;
        
    preferences|pref)
        # Preferences command - manage general preferences
        log_info "TFGrid Compose v$VERSION - Preferences Management"
        echo ""
        
        cmd_preferences "$@"
        exit $?
        ;;
        
    status)
        # Deployment status management
        log_info "TFGrid Compose v$VERSION - Status Management"
        echo ""
        
        SUBCOMMAND="${1:-list}"
        shift || true
        
        case "$SUBCOMMAND" in
            list|ls)
                # List all deployments with status
                echo "All deployments:"
                echo ""
                
                get_all_deployments | while IFS='|' read -r name status timestamp last_check; do
                    case "$status" in
                        "active")
                            echo "‚úÖ $name ($status) - $timestamp"
                            ;;
                        "failed")
                            echo "‚ùå $name ($status) - $timestamp"
                            ;;
                        "deploying")
                            echo "‚è≥ $name ($status) - $timestamp"
                            ;;
                        *)
                            echo "‚ùì $name ($status) - $timestamp"
                            ;;
                    esac
                done
                
                if [ -z "$(get_all_deployments)" ]; then
                    echo "(no deployments found)"
                fi
                ;;
            health|check)
                # Check health of specific deployment
                DEPLOYMENT_NAME="$1"
                
                if [ -z "$DEPLOYMENT_NAME" ]; then
                    log_error "Usage: tfgrid-compose status health <deployment-name>"
                    exit 1
                fi
                
                echo "Checking health of: $DEPLOYMENT_NAME"
                echo ""
                
                if perform_deployment_health_check "$DEPLOYMENT_NAME"; then
                    echo "‚úÖ Health check passed"
                    exit 0
                else
                    echo "‚ùå Health check failed"
                    echo ""
                    echo "Error details:"
                    get_deployment_logs "$DEPLOYMENT_NAME"
                    exit 1
                fi
                ;;
            retry)
                # Retry a failed deployment
                DEPLOYMENT_NAME="$1"
                
                if [ -z "$DEPLOYMENT_NAME" ]; then
                    log_error "Usage: tfgrid-compose status retry <deployment-name>"
                    exit 1
                fi
                
                echo "Retrying deployment: $DEPLOYMENT_NAME"
                echo ""
                
                # Reset status to deploying and retry
                mark_deployment_deploying "$DEPLOYMENT_NAME"
                tfgrid-compose up "$DEPLOYMENT_NAME"
                ;;
            logs)
                # Show deployment logs
                DEPLOYMENT_NAME="$1"
                
                if [ -z "$DEPLOYMENT_NAME" ]; then
                    log_error "Usage: tfgrid-compose status logs <deployment-name>"
                    exit 1
                fi
                
                get_deployment_logs "$DEPLOYMENT_NAME"
                ;;
            reset)
                # Reset deployment status
                DEPLOYMENT_NAME="$1"
                
                if [ -z "$DEPLOYMENT_NAME" ]; then
                    log_error "Usage: tfgrid-compose status reset <deployment-name>"
                    exit 1
                fi
                
                reset_deployment_status "$DEPLOYMENT_NAME"
                echo "Reset status for deployment: $DEPLOYMENT_NAME"
                ;;
            show|details)
                # Show detailed status of specific deployment
                DEPLOYMENT_NAME="$1"
                
                if [ -z "$DEPLOYMENT_NAME" ]; then
                    log_error "Usage: tfgrid-compose status show <deployment-name>"
                    exit 1
                fi
                
                get_deployment_status_details "$DEPLOYMENT_NAME" | jq '.' || cat
                ;;
            stats|statistics)
                # Show deployment statistics
                get_deployment_stats
                ;;
            *)
                log_error "Unknown status subcommand: $SUBCOMMAND"
                echo ""
                echo "Available subcommands:"
                echo "  list, ls          List all deployments with status"
                echo "  health, check      Check health of a deployment"
                echo "  retry              Retry a failed deployment"
                echo "  logs              Show deployment logs"
                echo "  reset             Reset deployment status"
                echo "  show, details     Show detailed status"
                echo "  stats, statistics Show deployment statistics"
                echo ""
                echo "Usage: tfgrid-compose status <subcommand> [options]"
                exit 1
                ;;
        esac
        ;;
        
    *)
        # Try to execute as app-specific command
        if execute_app_command "$COMMAND" "$@"; then
            exit 0
        else
            # Not an app command, show error
            exit 1
        fi
        ;;
esac
