#!/usr/bin/env bash
# TFGrid Compose - Main CLI entry point

set -e

# Get script directory
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
DEPLOYER_ROOT="$(cd "$SCRIPT_DIR/.." && pwd)"

# Source core modules
source "$DEPLOYER_ROOT/core/common.sh"
source "$DEPLOYER_ROOT/core/validation.sh"
source "$DEPLOYER_ROOT/core/pattern-loader.sh"
source "$DEPLOYER_ROOT/core/app-loader.sh"
source "$DEPLOYER_ROOT/core/orchestrator.sh"
source "$DEPLOYER_ROOT/core/registry.sh"
source "$DEPLOYER_ROOT/core/app-cache.sh"
source "$DEPLOYER_ROOT/core/deployment-state.sh"
source "$DEPLOYER_ROOT/core/login.sh"
source "$DEPLOYER_ROOT/core/gitconfig.sh"
source "$DEPLOYER_ROOT/core/config.sh"
source "$DEPLOYER_ROOT/core/update-git-config.sh"

# Version (read from VERSION file)
VERSION=$(cat "$DEPLOYER_ROOT/VERSION" 2>/dev/null || echo "unknown")

# Context file support
CONTEXT_FILE=".tfgrid-compose.yaml"

# Default manifest file
MANIFEST_FILE="tfgrid-compose.yaml"

# Load context from .tfgrid-compose.yaml or global current-app file
load_context() {
    # First try local context file
    if [ -f "$CONTEXT_FILE" ]; then
        grep "^app:" "$CONTEXT_FILE" | awk '{print $2}'
        return
    fi
    
    # Fall back to global current app (from switch command)
    if [ -f "$HOME/.config/tfgrid-compose/current-app" ]; then
        cat "$HOME/.config/tfgrid-compose/current-app"
    fi
}

# Get app command script path from manifest
get_app_command_script() {
    local app_path="$1"
    local command="$2"
    
    # Read command script from manifest (including any arguments after script path)
    grep -A 2 "^  ${command}:" "$app_path/tfgrid-compose.yaml" 2>/dev/null | \
        grep "script:" | sed 's/.*script:[[:space:]]*//'
}

# Check if selected app has a specific command
app_has_command() {
    local command="$1"
    
    # Get current app
    local current_app=$(get_current_app)
    if [ -z "$current_app" ]; then
        return 1
    fi
    
    # Resolve app path
    local app_path=$(resolve_app_path "$current_app" "true")
    if [ -z "$app_path" ] || [ ! -f "$app_path/tfgrid-compose.yaml" ]; then
        return 1
    fi
    
    # Check if command exists in manifest
    local script_path=$(get_app_command_script "$app_path" "$command")
    if [ -n "$script_path" ]; then
        return 0
    fi
    
    return 1
}

# Execute app-specific command
execute_app_command() {
    local command="$1"
    shift
    local args="$@"
    
    # Get smart context (auto-detect or use current)
    CONTEXT_APP=$(get_smart_context)
    
    if [ -z "$CONTEXT_APP" ]; then
        # Multiple or no apps, need explicit context
        log_error "No app selected"
        echo ""
        log_info "Deployed apps:"
        list_deployed_apps
        echo ""
        log_info "Select an app with: tfgrid-compose select <app>"
        return 1
    fi
    
    # Resolve app path
    APP_PATH=$(resolve_app_path "$CONTEXT_APP")
    if [ -z "$APP_PATH" ]; then
        log_error "Failed to resolve app: $CONTEXT_APP"
        return 1
    fi
    
    # Get command script
    SCRIPT_PATH=$(get_app_command_script "$APP_PATH" "$command")
    
    if [ -z "$SCRIPT_PATH" ]; then
        log_error "Unknown command: $command"
        log_info "App '$CONTEXT_APP' does not support command '$command'"
        echo ""
        log_info "Run 'tfgrid-compose help' to see available commands"
        return 1
    fi
    
    APP_NAME=$(basename "$APP_PATH")
    export APP_NAME
    
    # Get VM IP from state
    base_dir="${STATE_BASE_DIR:-$HOME/.config/tfgrid-compose/state}"
    state_dir="$base_dir/$APP_NAME"
    
    if [ ! -d "$state_dir" ]; then
        log_error "No deployment found for: $APP_NAME"
        log_info "Deploy first with: tfgrid-compose up $APP_NAME"
        return 1
    fi
    
    vm_ip=$(grep "^vm_ip:" "$state_dir/state.yaml" 2>/dev/null | awk '{print $2}')
    
    if [ -z "$vm_ip" ]; then
        log_error "No VM IP found in state for $APP_NAME"
        return 1
    fi
    
    # Execute command on VM
    log_info "Executing '$command' on $APP_NAME ($vm_ip)"
    echo ""
    
    # Use -t to allocate TTY for interactive commands
    ssh -t -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null -o LogLevel=ERROR \
        root@$vm_ip "$SCRIPT_PATH $args"
    
    return $?
}

# Resolve app input to path (handles both registry names and local paths)
resolve_app_path() {
    local app_input="$1"
    local quiet="${2:-false}"
    
    if [ -z "$app_input" ]; then
        return 1
    fi
    
    # If it's a path (contains / or starts with .), return as-is
    if [[ "$app_input" == */* ]] || [[ "$app_input" == .* ]]; then
        echo "$app_input"
        return 0
    fi
    
    # It's a registry app name - resolve to cached path
    local app_name="$app_input"
    local cached_path="$APP_CACHE_DIR/$app_name"
    
    if [ -d "$cached_path" ]; then
        echo "$cached_path"
        return 0
    fi
    
    # Not cached - try to download
    if [ "$quiet" != "true" ]; then
        log_info "Looking up $app_name in registry..."
    fi
    
    local repo_url=$(get_app_repo "$app_name")
    if [ -z "$repo_url" ]; then
        if [ "$quiet" != "true" ]; then
            log_error "App '$app_name' not found in registry"
        fi
        return 1
    fi
    
    local app_path=$(get_app "$app_name" "$repo_url")
    if [ -z "$app_path" ]; then
        return 1
    fi
    
    echo "$app_path"
    return 0
}

# Parse global flags
while [[ $# -gt 0 ]]; do
    case "$1" in
        -f|--file)
            MANIFEST_FILE="$2"
            shift 2
            ;;
        *)
            break
            ;;
    esac
done

# Export manifest file for other modules
export APP_MANIFEST_FILE="$MANIFEST_FILE"

# Command dispatcher
COMMAND="${1:-help}"
shift || true

# Handle commands
case "$COMMAND" in
    --version|version|-v)
        echo "TFGrid Compose v$VERSION"
        exit 0
        ;;
    
    search)
        # Search registry
        log_info "TFGrid Compose v$VERSION - Search Registry"
        echo ""
        
        QUERY="${1:-}"
        TAG="${2:-}"
        
        if [ -n "$TAG" ] && [ "$1" = "--tag" ]; then
            TAG="$2"
            QUERY=""
        fi
        
        log_info "Available apps:"
        echo ""
        
        if ! search_registry "$QUERY" "$TAG"; then
            log_error "Failed to search registry"
            exit 1
        fi
        
        echo ""
        log_info "Deploy an app: tfgrid-compose up <app-name>"
        exit 0
        ;;
    
    list)
        # List deployed apps
        log_info "TFGrid Compose v$VERSION - Deployed Apps"
        echo ""
        
        if ! list_deployed_apps; then
            log_warning "No apps deployed"
            echo ""
            log_info "Deploy an app: tfgrid-compose up <app-name>"
        else
            echo ""
            # Show smart context info
            SMART_CTX=$(get_smart_context)
            CURRENT=$(get_current_app)
            
            if [ -n "$SMART_CTX" ] && [ -z "$CURRENT" ]; then
                log_info "Using '$SMART_CTX' as default (only app deployed)"
            elif [ -n "$CURRENT" ]; then
                log_info "Active context: $CURRENT"
                log_info "Change with: tfgrid-compose select"
            fi
        fi
        
        exit 0
        ;;
    
    select)
        # Select active app
        APP_NAME="$1"
        
        if [ -z "$APP_NAME" ]; then
            # Interactive selection
            echo ""
            echo "üì± Select an app:"
            echo ""
            
            # Get list of deployed apps
            base_dir="${STATE_BASE_DIR:-$HOME/.config/tfgrid-compose/state}"
            
            if [ ! -d "$base_dir" ] || [ -z "$(ls -A "$base_dir" 2>/dev/null)" ]; then
                log_error "No apps deployed"
                echo ""
                log_info "Deploy an app first: tfgrid-compose up <app>"
                exit 1
            fi
            
            # Build array of apps
            APPS=()
            i=1
            for app_dir in "$base_dir"/*; do
                if [ -d "$app_dir" ]; then
                    app=$(basename "$app_dir")
                    APPS+=("$app")
                    
                    # Get VM IP if available
                    vm_ip=$(grep "^vm_ip:" "$app_dir/state.yaml" 2>/dev/null | awk '{print $2}')
                    
                    # Check if currently selected
                    CURRENT_APP_FILE="$HOME/.config/tfgrid-compose/current-app"
                    if [ -f "$CURRENT_APP_FILE" ] && [ "$(cat "$CURRENT_APP_FILE")" = "$app" ]; then
                        echo "  $i) $app ($vm_ip) ‚Üê (currently selected)"
                    else
                        echo "  $i) $app ($vm_ip)"
                    fi
                    
                    ((i++))
                fi
            done
            
            if [ ${#APPS[@]} -eq 0 ]; then
                log_error "No apps deployed"
                exit 1
            fi
            
            echo ""
            read -p "Enter number [1-${#APPS[@]}] or 'q' to quit: " choice
            
            if [ "$choice" = "q" ] || [ "$choice" = "Q" ]; then
                echo ""
                log_info "Cancelled"
                exit 0
            fi
            
            # Validate choice
            if ! [[ "$choice" =~ ^[0-9]+$ ]] || [ "$choice" -lt 1 ] || [ "$choice" -gt ${#APPS[@]} ]; then
                echo ""
                log_error "Invalid choice"
                exit 1
            fi
            
            # Get selected app (arrays are 0-indexed)
            APP_NAME="${APPS[$((choice-1))]}"
        fi
        
        if set_current_app "$APP_NAME"; then
            echo ""
            log_success "Selected $APP_NAME"
            log_info "App-specific commands will now take precedence"
            echo ""
        else
            exit 1
        fi
        
        exit 0
        ;;
        
    unselect)
        # Unselect active app
        CURRENT_APP_FILE="$HOME/.config/tfgrid-compose/current-app"
        if [ -f "$CURRENT_APP_FILE" ]; then
            CURRENT=$(cat "$CURRENT_APP_FILE")
            rm "$CURRENT_APP_FILE"
            log_success "Unselected $CURRENT"
            log_info "Built-in commands will now be used"
        else
            log_info "No app currently selected"
        fi
        exit 0
        ;;
        
    commands)
        # Show app-specific commands for selected app
        CURRENT_APP=$(get_current_app)
        
        if [ -z "$CURRENT_APP" ]; then
            log_error "No app selected"
            echo ""
            log_info "Select an app first: tfgrid-compose select"
            exit 1
        fi
        
        # Resolve app path
        APP_PATH=$(resolve_app_path "$CURRENT_APP")
        if [ -z "$APP_PATH" ] || [ ! -f "$APP_PATH/tfgrid-compose.yaml" ]; then
            log_error "Cannot find app: $CURRENT_APP"
            exit 1
        fi
        
        echo ""
        echo "üìã Commands for $CURRENT_APP:"
        echo ""
        
        # Parse commands section with sed/grep (compatible approach)
        in_commands=false
        current_cmd=""
        current_desc=""
        current_args=""
        
        while IFS= read -r line; do
            # Check if entering commands section
            if [[ "$line" == "commands:" ]]; then
                in_commands=true
                continue
            fi
            
            # Exit if we hit another top-level section
            if [ "$in_commands" = true ] && [[ "$line" =~ ^[a-z] ]]; then
                break
            fi
            
            # Parse command entries (2-space indent)
            if [ "$in_commands" = true ]; then
                if [[ "$line" =~ ^[[:space:]]{2}([a-z_-]+):$ ]]; then
                    # Print previous command if exists
                    if [ -n "$current_cmd" ]; then
                        if [ -n "$current_args" ]; then
                            printf "  ${GREEN}%-15s${NC} %s %s\n" "$current_cmd" "$current_args" "$current_desc"
                        else
                            printf "  ${GREEN}%-15s${NC} %s\n" "$current_cmd" "$current_desc"
                        fi
                    fi
                    
                    # Start new command
                    current_cmd="${BASH_REMATCH[1]}"
                    current_desc=""
                    current_args=""
                    
                elif [[ "$line" =~ ^[[:space:]]{4}description:[[:space:]]*(.+)$ ]]; then
                    current_desc="${BASH_REMATCH[1]}"
                    
                elif [[ "$line" =~ ^[[:space:]]{4}args:[[:space:]]*(.+)$ ]]; then
                    current_args="${BASH_REMATCH[1]}"
                fi
            fi
        done < "$APP_PATH/tfgrid-compose.yaml"
        
        # Print last command
        if [ -n "$current_cmd" ]; then
            if [ -n "$current_args" ]; then
                printf "  ${GREEN}%-15s${NC} %s %s\n" "$current_cmd" "$current_args" "$current_desc"
            else
                printf "  ${GREEN}%-15s${NC} %s\n" "$current_cmd" "$current_desc"
            fi
        fi
        
        echo ""
        log_info "Run commands with: tfgrid-compose <command> [args]"
        echo ""
        exit 0
        ;;
        
    up)
        # Deploy command
        log_info "TFGrid Compose v$VERSION"
        echo ""
        
        # Validate prerequisites
        if ! validate_prerequisites; then
            exit 1
        fi
        echo ""
        
        # Get app argument
        APP_INPUT="$1"
        if [ -z "$APP_INPUT" ]; then
            # Try loading from context
            APP_INPUT=$(get_current_app)
            if [ -z "$APP_INPUT" ]; then
                log_error "No app specified and no active app context"
                log_info "Usage: tfgrid-compose up <app-name>"
                log_info "Or:    tfgrid-compose up <app-path>"
                exit 1
            fi
            log_info "Using active app: $APP_INPUT"
        fi
        
        # Determine if input is app name or path
        APP_NAME=""
        APP_PATH=""
        
        if [[ "$APP_INPUT" == */* ]] || [[ "$APP_INPUT" == .* ]]; then
            # It's a path (contains / or starts with .)
            APP_PATH="$APP_INPUT"
            APP_NAME=$(basename "$APP_PATH")
            log_info "Deploying from path: $APP_PATH"
        else
            # It's an app name from registry
            APP_NAME="$APP_INPUT"
            log_info "Looking up $APP_NAME in registry..."
            
            # Get repo URL from registry
            REPO_URL=$(get_app_repo "$APP_NAME")
            if [ -z "$REPO_URL" ]; then
                log_error "App '$APP_NAME' not found in registry"
                log_info "Search apps: tfgrid-compose search"
                exit 1
            fi
            
            # Get or download app
            APP_PATH=$(get_app "$APP_NAME" "$REPO_URL")
            if [ -z "$APP_PATH" ]; then
                exit 1
            fi
            
            log_success "Using app: $APP_NAME"
        fi
        
        # Validate app path
        if ! validate_app_path "$APP_PATH"; then
            exit 1
        fi
        
        # Parse deployment flags FIRST (before checking deployment status)
        shift  # Remove app name
        PATTERN_NAME=""
        INTERACTIVE_MODE=false
        FORCE_DEPLOY=false
        CUSTOM_NODE=""
        CUSTOM_CPU=""
        CUSTOM_MEM=""
        CUSTOM_DISK=""
        CUSTOM_NETWORK=""
        
        while [[ $# -gt 0 ]]; do
            case $1 in
                --pattern)
                    PATTERN_NAME="$2"
                    shift 2
                    ;;
                --pattern=*)
                    PATTERN_NAME="${1#--pattern=}"
                    shift
                    ;;
                -i|--interactive)
                    INTERACTIVE_MODE=true
                    shift
                    ;;
                --force|-f)
                    FORCE_DEPLOY=true
                    shift
                    ;;
                --node)
                    CUSTOM_NODE="$2"
                    shift 2
                    ;;
                --cpu)
                    CUSTOM_CPU="$2"
                    shift 2
                    ;;
                --mem|--memory)
                    CUSTOM_MEM="$2"
                    shift 2
                    ;;
                --disk)
                    CUSTOM_DISK="$2"
                    shift 2
                    ;;
                --network)
                    CUSTOM_NETWORK="$2"
                    shift 2
                    ;;
                *)
                    log_warning "Unknown flag: $1"
                    shift
                    ;;
            esac
        done
        
        # Export for use in orchestrator
        export INTERACTIVE_MODE
        export CUSTOM_NODE
        export CUSTOM_CPU
        export CUSTOM_MEM
        export CUSTOM_DISK
        export CUSTOM_NETWORK
        
        # Check if app is already deployed or has stale state
        if is_app_deployed "$APP_NAME"; then
            # Check if deployment is healthy
            if is_deployment_healthy "$APP_NAME"; then
                if [ "$FORCE_DEPLOY" = "true" ]; then
                    log_warning "Force deploy requested, destroying existing deployment..."
                    export_app_state_dir "$APP_NAME"
                    # Load app for destroy operation
                    if ! load_app "$APP_PATH"; then
                        exit 1
                    fi
                    if ! destroy_deployment; then
                        log_error "Failed to destroy existing deployment"
                        exit 1
                    fi
                    echo ""
                else
                    log_error "App '$APP_NAME' is already deployed"
                    log_info "Destroy first: tfgrid-compose down $APP_NAME"
                    log_info "Or force redeploy: tfgrid-compose up $APP_NAME --force"
                    exit 1
                fi
            else
                # Deployment exists but unhealthy - clean stale state
                log_warning "Found unhealthy deployment state for $APP_NAME"
                
                # Check if force deploy is requested
                if [ "$FORCE_DEPLOY" = "true" ]; then
                    log_info "Force deploy requested, cleaning unhealthy state..."
                    clean_stale_state "$APP_NAME"
                    echo ""
                elif ! validate_terraform_state "$APP_NAME"; then
                    log_info "Detected stale Terraform state, cleaning..."
                    clean_stale_state "$APP_NAME"
                    echo ""
                else
                    log_error "Deployment exists but is unhealthy"
                    log_info "Use --force to clean and redeploy: tfgrid-compose up $APP_NAME --force"
                    exit 1
                fi
            fi
        fi
        
        # Initialize deployment state for this app
        init_deployment_state "$APP_NAME"
        export_app_state_dir "$APP_NAME"
        
        # Load app
        if ! load_app "$APP_PATH"; then
            exit 1
        fi
        
        # Determine pattern to use
        if [ -z "$PATTERN_NAME" ]; then
            PATTERN_NAME=$(get_recommended_pattern)
            if [ -z "$PATTERN_NAME" ]; then
                log_error "No pattern specified and no recommended pattern in manifest"
                log_info "Usage: tfgrid-compose up <app> --pattern=<pattern>"
                exit 1
            fi
            log_info "Using recommended pattern: $PATTERN_NAME"
        fi
        
        # Load pattern
        if ! load_pattern "$PATTERN_NAME"; then
            exit 1
        fi
        
        # Check compatibility
        if ! check_pattern_compatibility "$PATTERN_NAME"; then
            exit 1
        fi
        
        # Validate app structure
        if ! validate_app_structure; then
            exit 1
        fi
        
        # Validate pattern requirements
        if ! validate_pattern_requirements; then
            exit 1
        fi
        
        echo ""
        
        # Validate network prerequisites based on manifest config
        main_network=$(yaml_get "$APP_MANIFEST" "network.main")
        inter_node=$(yaml_get "$APP_MANIFEST" "network.inter_node")
        mode=$(yaml_get "$APP_MANIFEST" "network.mode")
        
        if ! validate_network_prerequisites "$main_network" "$inter_node" "$mode"; then
            log_error "Network validation failed"
            exit 1
        fi
        
        echo ""
        log_success "All validations passed! Starting deployment..."
        echo ""
        
        # Deploy the app
        if ! deploy_app; then
            log_error "Deployment failed"
            exit 1
        fi
        
        exit 0
        ;;
        
    down)
        # Down command
        log_info "TFGrid Compose v$VERSION"
        echo ""
        
        # Try to get app path from argument or context
        APP_PATH="$1"
        if [ -z "$APP_PATH" ]; then
            APP_PATH=$(load_context)
            if [ -z "$APP_PATH" ]; then
                log_error "No app specified and no context file found"
                log_info "Usage: tfgrid-compose down <app>"
                exit 1
            fi
            log_info "Using app from context: $APP_PATH"
        fi
        
        # Validate app path
        if ! validate_app_path "$APP_PATH"; then
            exit 1
        fi
        
        # Check deployment exists
        if ! validate_deployment_exists; then
            exit 1
        fi
        
        # Load mnemonic (needed for Terraform destroy)
        if ! load_mnemonic; then
            exit 1
        fi
        log_success "ThreeFold mnemonic configured"
        echo ""
        
        # Load app to get configuration (needed for Terraform variables)
        if ! load_app "$APP_PATH"; then
            exit 1
        fi
        
        # Get pattern from manifest
        PATTERN_NAME=$(get_recommended_pattern)
        if [ -z "$PATTERN_NAME" ]; then
            log_error "No pattern specified and no recommended pattern in manifest"
            exit 1
        fi
        
        # Load pattern (needed for generate_terraform_config)
        if ! load_pattern "$PATTERN_NAME"; then
            exit 1
        fi
        
        # Parse manifest and export Terraform variables (but don't copy infrastructure)
        # Just parse config to export TF_VAR_* environment variables
        log_info "Loading configuration from manifest..."
        
        # Parse nodes, resources, gateway, network config (no 'local' - not in function)
        gateway_nodes=$(yaml_get "$APP_MANIFEST" "nodes.gateway")
        backend_nodes=$(yaml_get "$APP_MANIFEST" "nodes.backend")
        vm_node=$(yaml_get "$APP_MANIFEST" "nodes.vm")
        
        if [ -n "$gateway_nodes" ]; then
            if [[ "$gateway_nodes" == "["* ]]; then
                export TF_VAR_gateway_node=$(echo "$gateway_nodes" | tr -d '[]' | awk '{print $1}' | tr -d ',')
            else
                export TF_VAR_gateway_node="$gateway_nodes"
            fi
        fi
        
        [ -n "$backend_nodes" ] && export TF_VAR_internal_nodes="$backend_nodes"
        [ -n "$vm_node" ] && export TF_VAR_vm_node="$vm_node"
        
        # Parse resources
        gateway_cpu=$(yaml_get "$APP_MANIFEST" "resources.gateway.cpu")
        gateway_mem=$(yaml_get "$APP_MANIFEST" "resources.gateway.memory")
        gateway_disk=$(yaml_get "$APP_MANIFEST" "resources.gateway.disk")
        backend_cpu=$(yaml_get "$APP_MANIFEST" "resources.backend.cpu")
        backend_mem=$(yaml_get "$APP_MANIFEST" "resources.backend.memory")
        backend_disk=$(yaml_get "$APP_MANIFEST" "resources.backend.disk")
        vm_cpu=$(yaml_get "$APP_MANIFEST" "resources.vm.cpu")
        vm_mem=$(yaml_get "$APP_MANIFEST" "resources.vm.memory")
        vm_disk=$(yaml_get "$APP_MANIFEST" "resources.vm.disk")
        
        [ -n "$gateway_cpu" ] && export TF_VAR_gateway_cpu="$gateway_cpu"
        [ -n "$gateway_mem" ] && export TF_VAR_gateway_mem="$gateway_mem"
        [ -n "$gateway_disk" ] && export TF_VAR_gateway_disk="$gateway_disk"
        [ -n "$backend_cpu" ] && export TF_VAR_internal_cpu="$backend_cpu"
        [ -n "$backend_mem" ] && export TF_VAR_internal_mem="$backend_mem"
        [ -n "$backend_disk" ] && export TF_VAR_internal_disk="$backend_disk"
        [ -n "$vm_cpu" ] && export TF_VAR_vm_cpu="$vm_cpu"
        [ -n "$vm_mem" ] && export TF_VAR_vm_mem="$vm_mem"
        [ -n "$vm_disk" ] && export TF_VAR_vm_disk="$vm_disk"
        
        # Parse network
        main_network=$(yaml_get "$APP_MANIFEST" "network.main")
        export MAIN_NETWORK="${main_network:-wireguard}"
        export TF_VAR_main_network="$MAIN_NETWORK"
        export TF_VAR_tfgrid_network="${TF_VAR_tfgrid_network:-main}"
        
        log_success "Configuration loaded from manifest"
        
        # Destroy the deployment
        if ! destroy_deployment; then
            log_error "Destroy failed"
            exit 1
        fi
        
        # Auto-unselect if this was the active app
        CURRENT_APP_FILE="$HOME/.config/tfgrid-compose/current-app"
        if [ -f "$CURRENT_APP_FILE" ]; then
            CURRENT_APP=$(cat "$CURRENT_APP_FILE")
            if [ "$CURRENT_APP" = "$APP_NAME" ]; then
                rm "$CURRENT_APP_FILE"
                echo ""
                log_info "Unselected (app no longer deployed)"
            fi
        fi
        
        exit 0
        ;;
        
    clean)
        # Clean up state directory
        log_info "TFGrid Compose v$VERSION"
        echo ""
        
        if [ -d "$STATE_DIR" ]; then
            log_warning "This will remove the local state directory: $STATE_DIR"
            read -p "Are you sure? (y/N): " -n 1 -r
            echo
            if [[ $REPLY =~ ^[Yy]$ ]]; then
                rm -rf "$STATE_DIR"
                log_success "State directory cleaned"
            else
                log_info "Cancelled"
            fi
        else
            log_info "No state directory found (already clean)"
        fi
        exit 0
        ;;
        
    logs)
        # Logs command - context-based precedence
        # If app is selected and has 'logs' command, use app version
        if app_has_command "logs"; then
            execute_app_command "logs" "$@"
            exit $?
        fi
        
        # Use built-in logs (pattern-based)
        # Try to get app from argument or context
        APP_INPUT="$1"
        if [ -z "$APP_INPUT" ]; then
            APP_INPUT=$(load_context)
            if [ -z "$APP_INPUT" ]; then
                log_error "No app specified and no app selected"
                log_info "Usage: tfgrid-compose logs <app>"
                log_info "   Or: tfgrid-compose select <app> && tfgrid-compose logs"
                exit 1
            fi
        fi
        
        # Resolve app path (registry name or local path)
        APP_PATH=$(resolve_app_path "$APP_INPUT")
        if [ -z "$APP_PATH" ]; then
            log_error "Failed to resolve app: $APP_INPUT"
            exit 1
        fi
        
        # Set app name for validation
        APP_NAME=$(basename "$APP_PATH")
        export APP_NAME
        
        # Validate app path
        if ! validate_app_path "$APP_PATH"; then
            exit 1
        fi
        
        # Check deployment exists
        if ! validate_deployment_exists; then
            exit 1
        fi
        
        # Load app to get pattern
        if ! load_app "$APP_PATH"; then
            exit 1
        fi
        
        # Get pattern from state (for now, use recommended)
        PATTERN_NAME=$(get_recommended_pattern)
        
        if [ -z "$PATTERN_NAME" ]; then
            log_error "Cannot determine pattern for app"
            exit 1
        fi
        
        # Load pattern
        if ! load_pattern "$PATTERN_NAME"; then
            exit 1
        fi
        
        # Execute pattern logs script
        execute_pattern_script "logs"
        ;;
        
    status)
        # Status command
        # Try to get app from argument or context
        APP_INPUT="$1"
        if [ -z "$APP_INPUT" ]; then
            APP_INPUT=$(load_context)
            if [ -z "$APP_INPUT" ]; then
                log_error "No app specified and no context file found"
                log_info "Usage: tfgrid-compose status <app>"
                exit 1
            fi
        fi
        
        # Resolve app path (registry name or local path)
        APP_PATH=$(resolve_app_path "$APP_INPUT")
        if [ -z "$APP_PATH" ]; then
            log_error "Failed to resolve app: $APP_INPUT"
            exit 1
        fi
        
        # Set app name for validation
        APP_NAME=$(basename "$APP_PATH")
        export APP_NAME
        
        # Validate app path
        if ! validate_app_path "$APP_PATH"; then
            exit 1
        fi
        
        # Check deployment exists
        if ! validate_deployment_exists; then
            exit 1
        fi
        
        # Load app
        if ! load_app "$APP_PATH"; then
            exit 1
        fi
        
        # Get pattern
        PATTERN_NAME=$(get_recommended_pattern)
        
        if [ -z "$PATTERN_NAME" ]; then
            log_error "Cannot determine pattern for app"
            exit 1
        fi
        
        # Load pattern
        if ! load_pattern "$PATTERN_NAME"; then
            exit 1
        fi
        
        # Execute pattern status script
        execute_pattern_script "status"
        ;;
        
    ssh|connect)
        # SSH command
        # Try to get app from argument or context
        APP_INPUT="$1"
        if [ -z "$APP_INPUT" ]; then
            APP_INPUT=$(load_context)
            if [ -z "$APP_INPUT" ]; then
                log_error "No app specified and no context file found"
                log_info "Usage: tfgrid-compose ssh <app>"
                exit 1
            fi
        fi
        
        # Resolve app path (registry name or local path)
        APP_PATH=$(resolve_app_path "$APP_INPUT")
        if [ -z "$APP_PATH" ]; then
            log_error "Failed to resolve app: $APP_INPUT"
            exit 1
        fi
        
        # Set and export app name
        APP_NAME=$(basename "$APP_PATH")
        export APP_NAME
        
        # Load app
        if ! load_app "$APP_PATH"; then
            exit 1
        fi
        
        # Get pattern
        PATTERN_NAME=$(get_recommended_pattern)
        
        if [ -z "$PATTERN_NAME" ]; then
            log_error "Cannot determine pattern for app"
            exit 1
        fi
        
        # Load pattern
        if ! load_pattern "$PATTERN_NAME"; then
            exit 1
        fi
        
        # Execute pattern connect script
        execute_pattern_script "connect"
        ;;
        
    address)
        # Address command
        if [ -z "$1" ]; then
            log_error "Usage: tfgrid-compose address <app>"
            exit 1
        fi
        
        APP_PATH="$1"
        
        # Load app
        if ! load_app "$APP_PATH"; then
            exit 1
        fi
        
        # Get pattern
        PATTERN_NAME=$(get_recommended_pattern)
        
        if [ -z "$PATTERN_NAME" ]; then
            log_error "Cannot determine pattern for app"
            exit 1
        fi
        
        # Load pattern
        if ! load_pattern "$PATTERN_NAME"; then
            exit 1
        fi
        
        # Execute pattern address script
        execute_pattern_script "address"
        ;;
        
    init)
        # Initialize app configuration
        if [ -z "$1" ]; then
            log_error "Usage: tfgrid-compose init <app>"
            exit 1
        fi
        
        APP_PATH="$1"
        
        log_info "TFGrid Compose v$VERSION - Initialize Configuration"
        echo ""
        
        # Load app
        if ! load_app "$APP_PATH"; then
            exit 1
        fi
        
        # Check if .env already exists
        if [ -f "$APP_DIR/.env" ]; then
            read -p "‚ö†Ô∏è  .env already exists. Overwrite? (y/N): " -n 1 -r
            echo
            if [[ ! $REPLY =~ ^[Yy]$ ]]; then
                log_info "Aborted."
                exit 0
            fi
        fi
        
        echo "üì° ThreeFold Grid Configuration"
        echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
        read -p "Node ID for VM: " NODE_ID
        if [ -z "$NODE_ID" ]; then
            log_error "Node ID is required"
            exit 1
        fi
        
        read -p "TFGrid Network (main/test/dev) [main]: " NETWORK
        NETWORK=${NETWORK:-main}
        
        echo ""
        echo "üîß VM Resources"
        echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
        
        # Get recommended resources from app
        REC_CPU=$(get_app_resource "cpu" "recommended")
        REC_MEM=$(get_app_resource "memory" "recommended")
        REC_DISK=$(get_app_resource "disk" "recommended")
        
        read -p "CPU cores [${REC_CPU:-4}]: " CPU
        CPU=${CPU:-${REC_CPU:-4}}
        read -p "Memory (MB) [${REC_MEM:-8192}]: " MEM
        MEM=${MEM:-${REC_MEM:-8192}}
        read -p "Disk (GB) [${REC_DISK:-100}]: " DISK
        DISK=${DISK:-${REC_DISK:-100}}
        
        echo ""
        echo "üåê Network Connectivity"
        echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
        read -p "Connectivity (wireguard/mycelium) [wireguard]: " CONN
        CONN=${CONN:-wireguard}
        
        # Git config from local
        GIT_NAME=$(git config --global user.name 2>/dev/null || echo "")
        GIT_EMAIL=$(git config --global user.email 2>/dev/null || echo "")
        
        echo ""
        echo "üîê Git Configuration"
        echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
        if [ -n "$GIT_NAME" ]; then
            echo "‚úÖ Found local git config:"
            echo "   Name:  $GIT_NAME"
            echo "   Email: $GIT_EMAIL"
            read -p "Use this config? (Y/n): " -n 1 -r
            echo
            if [[ $REPLY =~ ^[Nn]$ ]]; then
                read -p "Enter git name: " GIT_NAME
                read -p "Enter git email: " GIT_EMAIL
            fi
        else
            read -p "Git name: " GIT_NAME
            read -p "Git email: " GIT_EMAIL
        fi
        
        read -p "GitHub username (optional) [$GIT_NAME]: " GITHUB_USER
        GITHUB_USER=${GITHUB_USER:-$GIT_NAME}
        
        # Create .env
        cat > "$APP_DIR/.env" <<EOF
# TFGrid Compose Configuration for $APP_NAME
# Generated on $(date)

# ThreeFold Grid
export TF_VAR_tfgrid_network="$NETWORK"
export TF_VAR_ai_agent_node=$NODE_ID
export TF_VAR_ai_agent_cpu=$CPU
export TF_VAR_ai_agent_mem=$MEM
export TF_VAR_ai_agent_disk=$DISK

# Network
export CONNECTIVITY_NETWORK="$CONN"

# Git
export GIT_USER_NAME="$GIT_NAME"
export GIT_USER_EMAIL="$GIT_EMAIL"
EOF
        
        if [ -n "$GITHUB_USER" ]; then
            echo "export GITHUB_USER=\"$GITHUB_USER\"" >> "$APP_DIR/.env"
        fi
        
        echo ""
        log_success "Configuration saved to $APP_DIR/.env"
        echo ""
        log_info "Next steps:"
        echo "  1. Set your secrets (NEVER commit these!):"
        echo "     Fish: set -x TF_VAR_mnemonic (cat ~/.config/threefold/mnemonic)"
        echo "     Bash: export TF_VAR_mnemonic=\$(cat ~/.config/threefold/mnemonic)"
        echo ""
        echo "  2. Deploy your app:"
        echo "     tfgrid-compose up $APP_NAME"
        ;;
        
    exec)
        # Execute command on deployed VM
        # Usage: tfgrid-compose exec [app] <command> [args...]
        # If app is not specified, uses context from switch
        
        if [ -z "$1" ]; then
            log_error "No command specified"
            log_info "Usage: tfgrid-compose exec [app] <command> [args...]"
            log_info "Examples:"
            log_info "  tfgrid-compose exec ls /opt"
            log_info "  tfgrid-compose exec tfgrid-ai-agent ls /opt"
            exit 1
        fi
        
        # Simplified detection: Check if first arg is a deployed app
        FIRST_ARG="$1"
        APP_INPUT=""
        USE_CONTEXT=false
        
        # Check if first arg looks like an app (path or has context)
        if [[ "$FIRST_ARG" == */* ]] || [[ "$FIRST_ARG" == .* ]]; then
            # It's a path
            APP_INPUT="$1"
            shift
        else
            # Check if it's a deployed app name
            if [ -d "$STATE_BASE_DIR/$FIRST_ARG" ]; then
                # It's a deployed app
                APP_INPUT="$1"
                shift
            else
                # Not a deployed app, use context
                APP_INPUT=$(load_context)
                USE_CONTEXT=true
                if [ -z "$APP_INPUT" ]; then
                    log_error "No app specified and no context found"
                    log_info "Run 'tfgrid-compose switch <app>' first or specify app:"
                    log_info "  tfgrid-compose exec <app> <command>"
                    exit 1
                fi
                # Don't shift, $1 is the command
            fi
        fi
        
        # Check we have a command after figuring out the app
        if [ $# -eq 0 ]; then
            log_error "No command specified"
            log_info "Usage: tfgrid-compose exec [app] <command> [args...]"
            exit 1
        fi
        
        # Resolve app path
        APP_PATH=$(resolve_app_path "$APP_INPUT")
        if [ -z "$APP_PATH" ]; then
            log_error "Failed to resolve app: $APP_INPUT"
            exit 1
        fi
        
        APP_NAME=$(basename "$APP_PATH")
        export APP_NAME
        
        # Get VM IP from state
        base_dir="${STATE_BASE_DIR:-$HOME/.config/tfgrid-compose/state}"
        state_dir="$base_dir/$APP_NAME"
        
        if [ ! -d "$state_dir" ]; then
            log_error "No deployment found for: $APP_NAME"
            log_info "Deploy first with: tfgrid-compose up $APP_NAME"
            exit 1
        fi
        
        vm_ip=$(grep "^vm_ip:" "$state_dir/state.yaml" 2>/dev/null | awk '{print $2}')
        
        if [ -z "$vm_ip" ]; then
            log_error "No VM IP found in state for $APP_NAME"
            exit 1
        fi
        
        # Get the command and arguments
        REMOTE_CMD="$@"
        
        if [ "$USE_CONTEXT" = "true" ]; then
            log_info "Using context: $APP_NAME"
        fi
        log_info "Executing on $APP_NAME ($vm_ip): $REMOTE_CMD"
        echo ""
        
        # Execute command on VM
        ssh -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null -o LogLevel=ERROR \
            root@$vm_ip "$REMOTE_CMD"
        
        exit $?
        ;;
        
    patterns)
        # List available patterns
        log_info "TFGrid Compose v$VERSION"
        echo ""
        list_patterns
        ;;
        
    update)
        # Update command - install latest version from GitHub
        log_info "TFGrid Compose v$VERSION - Update"
        echo ""

        # Check if curl is available
        if ! command -v curl >/dev/null 2>&1; then
            log_error "curl is required for update. Please install curl first."
            exit 1
        fi

        # Check if git is available
        if ! command -v git >/dev/null 2>&1; then
            log_error "git is required for update. Please install git first."
            exit 1
        fi

        echo "üîÑ Checking for updates..."
        echo ""

        # Create temp directory
        TEMP_DIR=$(mktemp -d)
        trap "rm -rf '$TEMP_DIR'" EXIT

        # Clone latest version
        if ! git clone --depth 1 https://github.com/tfgrid-studio/tfgrid-compose.git "$TEMP_DIR/tfgrid-compose" >/dev/null 2>&1; then
            log_error "Failed to download latest version from GitHub"
            exit 1
        fi

        echo "üì¶ Installing latest version..."

        # Install the latest version
        cd "$TEMP_DIR/tfgrid-compose"
        if ! make install >/dev/null 2>&1; then
            log_error "Failed to install latest version"
            exit 1
        fi

        echo ""
        log_success "‚úÖ Successfully updated to latest version!"
        echo ""
        echo "üß™ Test with: tfgrid-compose --version"
        exit 0
        ;;

    login)
        # Login command - context-based precedence
        # If app is selected and has 'login' command, use app version
        if app_has_command "login"; then
            execute_app_command "login" "$@"
        else
            # Use built-in login
            cmd_login "$@"
        fi
        ;;


    logout)
        # Logout command
        cmd_logout
        ;;

    config)
        # Config command
        cmd_config "$@"
        ;;

    docs)
        # Documentation command
        DOCS_URL="https://docs.tfgrid.studio"
        
        echo ""
        echo "üìö TFGrid Compose Documentation"
        echo ""
        echo "‚Üí $DOCS_URL"
        echo ""
        
        sleep 0.5
        
        # Try to open in browser
        if command -v xdg-open &> /dev/null; then
            echo "Opening in browser..."
            sleep 0.5
            xdg-open "$DOCS_URL" >/dev/null 2>&1 &
            disown
            echo ""
            echo "‚úì Done"
        elif command -v open &> /dev/null; then
            echo "Opening in browser..."
            sleep 0.5
            open "$DOCS_URL" >/dev/null 2>&1 &
            echo "‚úì Done"
        else
            echo "‚Ñπ  Copy the URL above to open in your browser"
        fi
        echo ""
        ;;

    shortcut)
        # Shortcut command - create/manage command shortcuts
        SHORTCUT_NAME="$1"
        
        # Handle subcommands
        case "$SHORTCUT_NAME" in
            --list|-l)
                # List all shortcuts
                echo ""
                echo "üîó Active shortcuts:"
                echo ""
                
                FOUND=false
                for file in "$HOME/.local/bin"/*; do
                    if [ -L "$file" ] && [ "$(readlink "$file")" = "$HOME/.local/bin/tfgrid-compose" ]; then
                        echo "  ‚Ä¢ $(basename "$file") -> tfgrid-compose"
                        FOUND=true
                    fi
                done
                
                if [ "$FOUND" = "false" ]; then
                    echo "  (no shortcuts configured)"
                fi
                echo ""
                exit 0
                ;;
                
            --remove|-r)
                # Remove shortcut
                REMOVE_NAME="$2"
                if [ -z "$REMOVE_NAME" ]; then
                    log_error "Usage: tfgrid-compose shortcut --remove <name>"
                    exit 1
                fi
                
                # Don't allow removing tfgrid-compose itself
                if [ "$REMOVE_NAME" = "tfgrid-compose" ]; then
                    log_error "Cannot remove tfgrid-compose (main command)"
                    exit 1
                fi
                
                SHORTCUT_PATH="$HOME/.local/bin/$REMOVE_NAME"
                
                if [ ! -L "$SHORTCUT_PATH" ]; then
                    log_error "Shortcut '$REMOVE_NAME' does not exist"
                    exit 1
                fi
                
                if [ "$(readlink "$SHORTCUT_PATH")" != "$HOME/.local/bin/tfgrid-compose" ]; then
                    log_error "'$REMOVE_NAME' is not a tfgrid-compose shortcut"
                    exit 1
                fi
                
                rm "$SHORTCUT_PATH"
                log_success "Removed shortcut: $REMOVE_NAME"
                exit 0
                ;;
                
            --default|-d)
                # Reset to default (tfgrid)
                SHORTCUT_PATH="$HOME/.local/bin/tfgrid"
                
                if [ -L "$SHORTCUT_PATH" ] && [ "$(readlink "$SHORTCUT_PATH")" = "$HOME/.local/bin/tfgrid-compose" ]; then
                    log_info "Default shortcut 'tfgrid' already exists"
                else
                    ln -sf "$HOME/.local/bin/tfgrid-compose" "$SHORTCUT_PATH"
                    log_success "Created default shortcut: tfgrid"
                fi
                exit 0
                ;;
                
            --help|-h)
                # Show help
                echo ""
                echo "üîó Shortcut Management"
                echo ""
                echo "Usage:"
                echo "  tfgrid-compose shortcut               Interactive mode"
                echo "  tfgrid-compose shortcut <name>        Create shortcut"
                echo "  tfgrid-compose shortcut --list        List all shortcuts"
                echo "  tfgrid-compose shortcut --remove <name>  Remove shortcut"
                echo "  tfgrid-compose shortcut --default     Reset to 'tfgrid'"
                echo ""
                echo "Examples:"
                echo "  tfgrid-compose shortcut               # Interactive menu"
                echo "  tfgrid-compose shortcut tf            # Create 'tf' shortcut"
                echo "  tfgrid-compose shortcut grid          # Create 'grid' shortcut"
                echo "  tfgrid-compose shortcut --list        # Show all shortcuts"
                echo "  tfgrid-compose shortcut --remove tf   # Remove 'tf' shortcut"
                echo ""
                exit 0
                ;;
                
            "")
                # Interactive mode (no arguments)
                echo ""
                echo "üîó Shortcut Management (Interactive)"
                echo ""
                
                # Show current shortcuts
                echo "Current shortcuts:"
                FOUND=false
                for file in "$HOME/.local/bin"/*; do
                    if [ -L "$file" ] && [ "$(readlink "$file")" = "$HOME/.local/bin/tfgrid-compose" ]; then
                        echo "  ‚Ä¢ $(basename "$file")"
                        FOUND=true
                    fi
                done
                
                if [ "$FOUND" = "false" ]; then
                    echo "  (none configured)"
                fi
                echo ""
                
                # Interactive menu
                echo "What would you like to do?"
                echo "  1) Create a new shortcut"
                echo "  2) Remove a shortcut"
                echo "  3) List all shortcuts (detailed)"
                echo "  4) Reset to default (tfgrid)"
                echo "  5) Exit"
                echo ""
                
                read -p "Enter choice [1-5]: " choice
                
                case $choice in
                    1)
                        # Create shortcut
                        echo ""
                        echo "Popular choices: tf, grid, tfc"
                        read -p "Enter shortcut name: " new_name
                        
                        if [ -z "$new_name" ]; then
                            log_error "No name provided"
                            exit 1
                        fi
                        
                        # Validate shortcut name
                        if [[ ! "$new_name" =~ ^[a-zA-Z][a-zA-Z0-9_-]*$ ]]; then
                            log_error "Invalid shortcut name: $new_name"
                            log_info "Name must start with a letter and contain only letters, numbers, hyphens, and underscores"
                            exit 1
                        fi
                        
                        # Don't allow overwriting tfgrid-compose itself
                        if [ "$new_name" = "tfgrid-compose" ]; then
                            log_error "Cannot use 'tfgrid-compose' as shortcut name"
                            exit 1
                        fi
                        
                        # Check if command already exists in PATH
                        if command -v "$new_name" &> /dev/null; then
                            EXISTING_CMD=$(command -v "$new_name")
                            # Skip warning if it's already our shortcut
                            if [ ! -L "$EXISTING_CMD" ] || [ "$(readlink "$EXISTING_CMD")" != "$HOME/.local/bin/tfgrid-compose" ]; then
                                echo ""
                                log_warning "Command '$new_name' already exists!"
                                log_info "Existing command: $EXISTING_CMD"
                                log_info "Creating this shortcut will shadow the existing command"
                                echo ""
                                read -p "Continue anyway? (y/N): " confirm
                                if [[ ! $confirm =~ ^[Yy]$ ]]; then
                                    echo ""
                                    log_info "Cancelled - shortcut not created"
                                    echo ""
                                    exit 0
                                fi
                            fi
                        fi
                        
                        SHORTCUT_PATH="$HOME/.local/bin/$new_name"
                        
                        # Warn if shortcut already exists
                        if [ -e "$SHORTCUT_PATH" ]; then
                            if [ -L "$SHORTCUT_PATH" ] && [ "$(readlink "$SHORTCUT_PATH")" = "$HOME/.local/bin/tfgrid-compose" ]; then
                                log_info "Shortcut '$new_name' already exists"
                                exit 0
                            else
                                log_error "File '$new_name' already exists in ~/.local/bin"
                                log_info "Choose a different name"
                                exit 1
                            fi
                        fi
                        
                        # Create symlink
                        ln -s "$HOME/.local/bin/tfgrid-compose" "$SHORTCUT_PATH"
                        echo ""
                        log_success "Created shortcut: $new_name"
                        echo ""
                        log_info "You can now use: $new_name <command>"
                        echo ""
                        ;;
                        
                    2)
                        # Remove shortcut
                        echo ""
                        read -p "Enter shortcut name to remove: " remove_name
                        
                        if [ -z "$remove_name" ]; then
                            log_error "No name provided"
                            exit 1
                        fi
                        
                        # Don't allow removing tfgrid-compose itself
                        if [ "$remove_name" = "tfgrid-compose" ]; then
                            log_error "Cannot remove tfgrid-compose (main command)"
                            exit 1
                        fi
                        
                        SHORTCUT_PATH="$HOME/.local/bin/$remove_name"
                        
                        if [ ! -L "$SHORTCUT_PATH" ]; then
                            log_error "Shortcut '$remove_name' does not exist"
                            exit 1
                        fi
                        
                        if [ "$(readlink "$SHORTCUT_PATH")" != "$HOME/.local/bin/tfgrid-compose" ]; then
                            log_error "'$remove_name' is not a tfgrid-compose shortcut"
                            exit 1
                        fi
                        
                        rm "$SHORTCUT_PATH"
                        echo ""
                        log_success "Removed shortcut: $remove_name"
                        echo ""
                        ;;
                        
                    3)
                        # List shortcuts (detailed)
                        echo ""
                        echo "üîó Active shortcuts:"
                        echo ""
                        
                        FOUND=false
                        for file in "$HOME/.local/bin"/*; do
                            if [ -L "$file" ] && [ "$(readlink "$file")" = "$HOME/.local/bin/tfgrid-compose" ]; then
                                echo "  ‚Ä¢ $(basename "$file") -> tfgrid-compose"
                                FOUND=true
                            fi
                        done
                        
                        if [ "$FOUND" = "false" ]; then
                            echo "  (no shortcuts configured)"
                        fi
                        echo ""
                        ;;
                        
                    4)
                        # Reset to default
                        echo ""
                        SHORTCUT_PATH="$HOME/.local/bin/tfgrid"
                        
                        if [ -L "$SHORTCUT_PATH" ] && [ "$(readlink "$SHORTCUT_PATH")" = "$HOME/.local/bin/tfgrid-compose" ]; then
                            log_info "Default shortcut 'tfgrid' already exists"
                        else
                            ln -sf "$HOME/.local/bin/tfgrid-compose" "$SHORTCUT_PATH"
                            log_success "Created default shortcut: tfgrid"
                        fi
                        echo ""
                        ;;
                        
                    5)
                        # Exit
                        echo ""
                        log_info "Goodbye!"
                        echo ""
                        exit 0
                        ;;
                        
                    *)
                        log_error "Invalid choice"
                        exit 1
                        ;;
                esac
                
                exit 0
                ;;
                
            *)
                # Create new shortcut
                if [ -z "$SHORTCUT_NAME" ]; then
                    log_error "Usage: tfgrid-compose shortcut <name>"
                    log_info "Try: tfgrid-compose shortcut --help"
                    exit 1
                fi
                
                # Validate shortcut name
                if [[ ! "$SHORTCUT_NAME" =~ ^[a-zA-Z][a-zA-Z0-9_-]*$ ]]; then
                    log_error "Invalid shortcut name: $SHORTCUT_NAME"
                    log_info "Name must start with a letter and contain only letters, numbers, hyphens, and underscores"
                    exit 1
                fi
                
                # Don't allow overwriting tfgrid-compose itself
                if [ "$SHORTCUT_NAME" = "tfgrid-compose" ]; then
                    log_error "Cannot use 'tfgrid-compose' as shortcut name"
                    exit 1
                fi
                
                # Check if command already exists in PATH
                if command -v "$SHORTCUT_NAME" &> /dev/null; then
                    EXISTING_CMD=$(command -v "$SHORTCUT_NAME")
                    # Skip warning if it's already our shortcut
                    if [ ! -L "$EXISTING_CMD" ] || [ "$(readlink "$EXISTING_CMD")" != "$HOME/.local/bin/tfgrid-compose" ]; then
                        echo ""
                        log_warning "Command '$SHORTCUT_NAME' already exists!"
                        log_info "Existing command: $EXISTING_CMD"
                        log_info "Creating this shortcut will shadow the existing command"
                        echo ""
                        read -p "Continue anyway? (y/N): " confirm
                        if [[ ! $confirm =~ ^[Yy]$ ]]; then
                            echo ""
                            log_info "Cancelled - shortcut not created"
                            echo ""
                            exit 0
                        fi
                    fi
                fi
                
                SHORTCUT_PATH="$HOME/.local/bin/$SHORTCUT_NAME"
                
                # Warn if shortcut already exists
                if [ -e "$SHORTCUT_PATH" ]; then
                    if [ -L "$SHORTCUT_PATH" ] && [ "$(readlink "$SHORTCUT_PATH")" = "$HOME/.local/bin/tfgrid-compose" ]; then
                        log_info "Shortcut '$SHORTCUT_NAME' already exists"
                        exit 0
                    else
                        log_error "File '$SHORTCUT_NAME' already exists in ~/.local/bin"
                        log_info "Choose a different name"
                        exit 1
                    fi
                fi
                
                # Create symlink
                ln -s "$HOME/.local/bin/tfgrid-compose" "$SHORTCUT_PATH"
                
                echo ""
                log_success "Created shortcut: $SHORTCUT_NAME"
                echo ""
                log_info "You can now use: $SHORTCUT_NAME <command>"
                echo ""
                log_info "Example: $SHORTCUT_NAME up"
                echo ""
                
                exit 0
                ;;
        esac
        ;;

    update-git-config)
        # Update git config on running VM
        update_git_config "$1"
        ;;

    version|--version|-v)
        # Version command
        echo "TFGrid Compose v$VERSION"
        ;;

    help|--help|-h|"")
        # Help command
        show_help
        ;;

    *)
        # Try to execute as app-specific command
        if execute_app_command "$COMMAND" "$@"; then
            exit 0
        else
            # Not an app command, show error
            exit 1
        fi
        ;;
esac
