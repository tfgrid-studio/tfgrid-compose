#!/usr/bin/env node

/**
 * TFGrid AI Stack - AI Agent Project Management API
 * Version: 0.12.0-dev (MVP)
 * 
 * Orchestrates project creation: AI generation → Gitea repo → Gateway deployment
 */

const express = require('express');
const bodyParser = require('body-parser');
const axios = require('axios');
const { v4: uuidv4 } = require('uuid');
const fs = require('fs').promises;
const path = require('path');
const { exec } = require('child_process');
const util = require('util');
const execAsync = util.promisify(exec);

const app = express();
const PORT = process.env.PORT || 8080;

// Configuration from environment
const GATEWAY_IP = process.env.GATEWAY_IP || 'localhost';
const GATEWAY_API_KEY = process.env.GATEWAY_API_KEY || 'dev-api-key';
const GITEA_IP = process.env.GITEA_IP || 'localhost';
const GITEA_ADMIN_USER = process.env.GITEA_ADMIN_USER || 'gitadmin';
const GITEA_ADMIN_PASSWORD = process.env.GITEA_ADMIN_PASSWORD || 'admin';
const PROJECTS_DIR = process.env.PROJECTS_DIR || '/opt/ai-agent/projects';

// Middleware
app.use(bodyParser.json());

// Simple logging
const log = (level, message, data = {}) => {
  console.log(JSON.stringify({
    timestamp: new Date().toISOString(),
    level,
    message,
    ...data
  }));
};

// In-memory project storage (MVP - would be database in production)
const projects = new Map();

// Helper functions

/**
 * Generate simple website using template (MVP - would use AI in production)
 */
async function generateCode(description) {
  log('info', 'Generating code', { description });
  
  // MVP: Generate a simple HTML template
  // In production, this would call qwen-cli or similar AI model
  const html = `<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>${description}</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
        }
        .container {
            background: white;
            border-radius: 20px;
            padding: 60px 40px;
            max-width: 600px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
            text-align: center;
        }
        h1 {
            color: #333;
            margin-bottom: 20px;
            font-size: 2.5em;
        }
        p {
            color: #666;
            line-height: 1.6;
            font-size: 1.1em;
        }
        .badge {
            display: inline-block;
            background: #667eea;
            color: white;
            padding: 8px 20px;
            border-radius: 20px;
            margin-top: 30px;
            font-size: 0.9em;
        }
        .footer {
            margin-top: 30px;
            color: #999;
            font-size: 0.9em;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>🚀 ${description}</h1>
        <p>This website was automatically generated and deployed by TFGrid AI Stack!</p>
        <p>Project created: ${new Date().toISOString()}</p>
        <div class="badge">✨ AI Generated</div>
        <div class="footer">
            Powered by TFGrid Studio<br>
            <small>Deployed on ThreeFold Grid</small>
        </div>
    </div>
</body>
</html>`;

  return {
    'index.html': html,
    'README.md': `# ${description}\n\nGenerated by TFGrid AI Stack\nCreated: ${new Date().toISOString()}\n`
  };
}

/**
 * Create Gitea repository
 */
async function createGiteaRepo(projectId, description) {
  log('info', 'Creating Gitea repository', { projectId });
  
  try {
    const response = await axios.post(
      `http://${GITEA_IP}:3000/api/v1/user/repos`,
      {
        name: projectId,
        description: description,
        private: false,
        auto_init: false
      },
      {
        auth: {
          username: GITEA_ADMIN_USER,
          password: GITEA_ADMIN_PASSWORD
        }
      }
    );
    
    log('info', 'Gitea repository created', { projectId, repo_url: response.data.html_url });
    return response.data;
  } catch (error) {
    log('error', 'Failed to create Gitea repository', { 
      projectId, 
      error: error.message,
      details: error.response?.data 
    });
    throw new Error(`Gitea repository creation failed: ${error.message}`);
  }
}

/**
 * Deploy files to gateway
 */
async function deployToGateway(projectId, files) {
  log('info', 'Deploying to gateway', { projectId });
  
  const projectPath = `/var/www/${projectId}`;
  
  // Create project directory on gateway
  await execAsync(`ssh root@${GATEWAY_IP} "mkdir -p ${projectPath}"`);
  
  // Write files locally first
  const localPath = path.join(PROJECTS_DIR, projectId);
  await fs.mkdir(localPath, { recursive: true });
  
  for (const [filename, content] of Object.entries(files)) {
    await fs.writeFile(path.join(localPath, filename), content);
  }
  
  // Copy to gateway
  await execAsync(`scp -r ${localPath}/* root@${GATEWAY_IP}:${projectPath}/`);
  
  log('info', 'Files deployed to gateway', { projectId, path: projectPath });
  return projectPath;
}

/**
 * Add nginx route via Gateway API
 */
async function addGatewayRoute(projectId, backend) {
  log('info', 'Adding gateway route', { projectId });
  
  try {
    const response = await axios.post(
      `http://${GATEWAY_IP}:3000/api/v1/routes`,
      {
        path: `/${projectId}`,
        backend: backend
      },
      {
        headers: {
          'Authorization': `Bearer ${GATEWAY_API_KEY}`,
          'Content-Type': 'application/json'
        }
      }
    );
    
    log('info', 'Gateway route created', { projectId, route_id: response.data.id });
    return response.data;
  } catch (error) {
    log('error', 'Failed to create gateway route', { 
      projectId, 
      error: error.message,
      details: error.response?.data 
    });
    throw new Error(`Gateway route creation failed: ${error.message}`);
  }
}

/**
 * Rollback project on failure
 */
async function rollbackProject(projectId, steps) {
  log('warn', 'Rolling back project', { projectId, steps });
  
  for (const step of steps) {
    try {
      if (step === 'route') {
        // Delete route - would need route_id in production
        log('info', 'Rollback: deleting route', { projectId });
      } else if (step === 'files') {
        // Delete files from gateway
        await execAsync(`ssh root@${GATEWAY_IP} "rm -rf /var/www/${projectId}"`);
        log('info', 'Rollback: deleted files', { projectId });
      } else if (step === 'repo') {
        // Delete Gitea repo
        await axios.delete(
          `http://${GITEA_IP}:3000/api/v1/repos/${GITEA_ADMIN_USER}/${projectId}`,
          {
            auth: {
              username: GITEA_ADMIN_USER,
              password: GITEA_ADMIN_PASSWORD
            }
          }
        );
        log('info', 'Rollback: deleted repository', { projectId });
      }
    } catch (error) {
      log('error', 'Rollback step failed', { projectId, step, error: error.message });
    }
  }
}

// API Routes

/**
 * Health check
 * GET /health
 */
app.get('/health', (req, res) => {
  res.json({
    status: 'healthy',
    uptime: process.uptime(),
    projects: projects.size,
    timestamp: new Date().toISOString()
  });
});

/**
 * Create a new project
 * POST /api/v1/projects
 */
app.post('/api/v1/projects', async (req, res) => {
  const startTime = Date.now();
  const { description } = req.body;
  
  if (!description) {
    return res.status(400).json({ error: 'Description is required' });
  }
  
  const projectId = `project-${Date.now()}`;
  const completedSteps = [];
  
  try {
    log('info', 'Starting project creation', { projectId, description });
    
    // Update project status
    projects.set(projectId, {
      id: projectId,
      description,
      status: 'creating',
      created_at: new Date().toISOString()
    });
    
    // Step 1: Generate code
    log('info', 'Step 1/4: Generating code', { projectId });
    const files = await generateCode(description);
    completedSteps.push('generation');
    
    // Step 2: Create Gitea repository
    log('info', 'Step 2/4: Creating repository', { projectId });
    const repo = await createGiteaRepo(projectId, description);
    completedSteps.push('repo');
    
    // Step 3: Deploy to gateway
    log('info', 'Step 3/4: Deploying files', { projectId });
    const deployPath = await deployToGateway(projectId, files);
    completedSteps.push('files');
    
    // Step 4: Add nginx route
    log('info', 'Step 4/4: Creating route', { projectId });
    const route = await addGatewayRoute(projectId, deployPath);
    completedSteps.push('route');
    
    // Calculate duration
    const duration = (Date.now() - startTime) / 1000;
    
    // Update project
    const liveUrl = `http://${GATEWAY_IP}/${projectId}`;
    projects.set(projectId, {
      id: projectId,
      description,
      repo_url: repo.html_url,
      live_url: liveUrl,
      route_id: route.id,
      status: 'active',
      created_at: new Date().toISOString(),
      duration
    });
    
    log('info', 'Project created successfully', { 
      projectId, 
      duration: `${duration}s` 
    });
    
    res.status(201).json({
      project_id: projectId,
      repo_url: repo.html_url,
      live_url: liveUrl,
      duration
    });
    
  } catch (error) {
    log('error', 'Project creation failed', { 
      projectId, 
      error: error.message,
      completed_steps: completedSteps
    });
    
    // Attempt rollback
    await rollbackProject(projectId, completedSteps.reverse());
    
    // Update project status
    projects.set(projectId, {
      ...projects.get(projectId),
      status: 'failed',
      error: error.message
    });
    
    res.status(500).json({ 
      error: 'Project creation failed', 
      details: error.message,
      projectId 
    });
  }
});

/**
 * List all projects
 * GET /api/v1/projects
 */
app.get('/api/v1/projects', (req, res) => {
  const projectList = Array.from(projects.values());
  res.json(projectList);
});

/**
 * Get project by ID
 * GET /api/v1/projects/:id
 */
app.get('/api/v1/projects/:id', (req, res) => {
  const { id } = req.params;
  const project = projects.get(id);
  
  if (!project) {
    return res.status(404).json({ error: 'Project not found' });
  }
  
  res.json(project);
});

/**
 * Delete a project
 * DELETE /api/v1/projects/:id
 */
app.delete('/api/v1/projects/:id', async (req, res) => {
  const { id } = req.params;
  
  const project = projects.get(id);
  if (!project) {
    return res.status(404).json({ error: 'Project not found' });
  }
  
  try {
    await rollbackProject(id, ['route', 'files', 'repo']);
    projects.delete(id);
    
    log('info', 'Project deleted', { projectId: id });
    res.status(204).send();
  } catch (error) {
    log('error', 'Failed to delete project', { projectId: id, error: error.message });
    res.status(500).json({ error: 'Failed to delete project' });
  }
});

// Start server
app.listen(PORT, () => {
  log('info', 'AI Agent API started', { 
    port: PORT,
    gateway_ip: GATEWAY_IP,
    gitea_ip: GITEA_IP
  });
  console.log(`
╔════════════════════════════════════════════════════════════╗
║     TFGrid AI Agent API - Running                          ║
╚════════════════════════════════════════════════════════════╝

Port: ${PORT}
Health Check: http://localhost:${PORT}/health

Configuration:
  Gateway IP: ${GATEWAY_IP}
  Gitea IP: ${GITEA_IP}
  Projects Dir: ${PROJECTS_DIR}

API Endpoints:
  POST   /api/v1/projects      Create project
  GET    /api/v1/projects      List projects
  GET    /api/v1/projects/:id  Get project
  DELETE /api/v1/projects/:id  Delete project
  GET    /health               Health check

Ready to create projects...
`);
});

// Graceful shutdown
process.on('SIGTERM', () => {
  log('info', 'SIGTERM received, shutting down gracefully');
  process.exit(0);
});

process.on('SIGINT', () => {
  log('info', 'SIGINT received, shutting down gracefully');
  process.exit(0);
});

module.exports = app;